<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title><![CDATA[reviewSQL]]></title>
    <url>%2FmarkdownBlog.github.io%2F2020%2F02%2F08%2FreviewSQL%2F</url>
    <content type="text"><![CDATA[NoSQL 与 SQLSQL（Structured Query Language）数据库，指关系型数据库。NoSQL（Not Only SQL）泛指非关系型数据库。 NoSQL分类：（1）Key-value stores键值存储, 保存keys+BLOBs (二进制大对象Binary Large OBjects)（2）Table-oriented 面向表列, 主要有Google的BigTable和Cassandra.（3）Document-oriented面向文档, 文本是一种类似XML文档，MongoDB 和 CouchDB（4）Graph-oriented 面向图论. 如Neo4J mongoDB常用命令exit 退出show dbs 显示所有数据库use dbName 使用/创建数据库db 查看当前使用的数据库db.dropDatabase(); 删除当前数据库db.collection.drop(); 删除集合 show collections 显示当前数据库的所有集合db.集合名.insert({}) 创建集合并插入一条数据db.集合名.insertMany([{},{}]) 创建集合并插入多条数据db.集合名.save({}) 创建集合并插入数据，如果集合存在数据则更新数据db.集合名.drop() 删除集合 db.collection.find() 查看当前集合的所有数据db.collection.find({条件对象}) 查看当前集合的符合条件的数据db.col.find().pretty() 以格式化的方式来显示所有文档。db.col.find({‘age’:{$gt:30, $lt:50}}) 查找年龄在大于30小于40的数据db.col.find({‘key’:{$mod:[10, 1]}}) 查找除于10余数为1的Keydb.col.find({‘key’:{$in:[1, 2, 3]}}) 查找值为1， 2， 3的Keydb.col.find({‘key’:{$size:3}}) 查找数量、尺寸为3的Key，key为数组查看满足key1或key2的文档db.col.find( { $or: [ {key1: value1}, {key2:value2} ] }).pretty()sort() 方法可以通过参数指定排序的字段，并使用 1 和 -1 来指定排序的方式，其中 1 为升序排列，而 -1 是用于降序排列。db.COLLECTION_NAME.find().sort({KEY:1})db.COLLECTION_NAME.find().limit(NUMBER) 限制查找条数为numberdb.COLLECTION_NAME.find().limit(NUMBER).skip(NUMBER) 跳过前number条数据查找 eg:查找年龄在第五六七的人db.user.find().sort({‘age’:-1}).limit(3).skip(4)拓展，limit和skip主要用于分页，如100条数据，一页10条，总共10页，若在第二页上，则跳过前10条，查找11-20的数据 模糊查询（利用正则表达式）db.user.find({‘name’:/刘/}) 查找姓刘的用户 更新数据db.collection.update( , , { upsert: , 如果不存在update的记录，是否插入objNew,true为插入，默认是false，不插入。 multi: , 只更新找到的第一条记录，如果这个参数为true,就把按条件查出来多条记录全部更新。 writeConcern: })eg： db.col.update({‘title’:’MongoDB 教程’},{$set:{‘title’:’MongoDB’}}) 删除数据db.collection.remove( , ) 使用Mongoose操作数据库 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152mongoose.connect('mongodb://localhost/app', &#123;useNewUrlParser:true, useUnifiedTopology: true&#125;, err =&gt; &#123; if (err) &#123; throw err; &#125; else &#123; console.log('数据库连接成功'); &#125;&#125;);// 定义骨架，如果没定义的数据类型不能插入var userSchema = new mongoose.Schema(&#123; age: Number&#125;);// 定义模型var userModel = mongoose.model('user', userSchema, 'user');userModel.find(&#123;&#125;, (err, bson) =&gt; &#123; if (err) &#123; throw err; &#125; // console.log(bson.toString()) data.users = data.users.concat(bson)&#125;);// 添加数据var user = new userModel();user.age = 50;user.save((err) =&gt; &#123; if (err) throw err;&#125;);// 删除数据router.get('/del.html', (req, res) =&gt; &#123; // var id = req.query.id; // userModel.findById(id).exec((err, data) =&gt; &#123; // // res.send(data); // if (err) &#123; // throw err; // &#125; // data.remove(err =&gt; &#123; // if (err) &#123; // throw err; // &#125; // res.send('&lt;h1&gt;删除成功&lt;/h1&gt;'); // &#125;) // &#125;) userModel.deleteMany(&#123;age: 50 &#125;, function (err) &#123; if (err) &#123; throw err; &#125; &#125;);&#125;)]]></content>
      <tags>
        <tag>sql</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[reviewNode]]></title>
    <url>%2FmarkdownBlog.github.io%2F2020%2F01%2F10%2FreviewNode%2F</url>
    <content type="text"><![CDATA[控制命令console.log()console.error(‘错误类型’)console.time(‘flag’)console.timeEnd(‘flag’)console.assert(exc, info) // 但表达式为flase时，输出信息info 全局对象global.属性方法 回调函数异步一定有回调函数123setTimeout(function() &#123; consle.log('...');&#125;, 1000) 回调函数不一定是异步12345cons0le.log(1)arr.forEach((v) =&gt; &#123; consle.log(v)&#125;)console.log(2) 异步实现方式事件源.on(事件名, 回调函数) 回调函数的作用：用于达到某个时间或条件执行的函数（代码），即某个时间发生或某个任务完成时执行12345678910111213141516171819202122232425262728;(function () &#123; // 定义show方法，接受url参数和fn函数 $.fn.show = function (url， fn) &#123; var iframe = $('&lt;iframe src="' + url + '"&gt;&lt;/iframe&gt;').appendTo('body'); var data; console.log(1); iframe.on('load', function () &#123; console.log(2); 获取url内部body的内容 data = $(this.contentDocument).find('body').text(); data = JSON.parse(data); // 调用异步回调函数，并传递data值 fn(data); &#125;); console.log(3); // return data; 此句返回undefined，因为iframe.on()方法是异步执行，return可能在on方法执行之前返回 &#125;&#125;)();// 调用show方法// var data = $('body').show('./data.json');// console.log(data);// 调用show方法，定义异步回调函数fn$('body').show('./data.json', function(a) &#123; console.log(a);&#125;); 1234567891011121314151617181920212223242526272829303132333435363738394041424344// module dbConfig.jsvar mysql = require('mysql'); // 传递回调函数callbackfunction connectSql(callback) &#123; var connection = mysql.createConnection(&#123; host: 'localhost', user: 'root', password: '19961026', database: 'forum', port: 3306 &#125;); connection.connect(); console.log(1); // 调用执行回调函数，传递参数connection callback(connection); connection.end(); console.log(2);&#125;module.exports = connectSql;// module users.jsvar connectSql = require('./db/dbConfig');// 定义回调函数checkPass，参数为connectionconnectSql(checkPass)function checkPass(connection) &#123; console.log(3); var sql = 'SELECT * FROM users WHERE name = ? AND password = ?'; var sqlParams = [req.body.userName, req.body.password]; console.log(sqlParams); //查 connection.query(sql, sqlParams, function (err, result) &#123; if(err)&#123; console.log('[SELECT ERROR] - ',err.message); res.send('系统错误'); &#125; else if(result.length===0) &#123; res.send('账号或密码错误'); &#125; else &#123; res.send('登录成功'); &#125; &#125;);&#125; module.exports是暴露原始对象；exports是暴露原始对象的引用，不能改变指向，只能添加属性和方法12345678910111213141516171819202122var username = 'yxm'function show () &#123; consle.log(username);&#125;// 暴露到调用处// 语法exports.属性名=值，exports.方法名=函数// exports.show = show;// 调用处调用执行// var obj = require('show.js');// obj.show() 输出yxm// 两者指向同一内存空间// exports是module.exports的引用console.log(exports === module.exports)// 执行obj()出错，因为此时obj为空对象&#123;&#125;// exports = show;module.exports = show;// 执行obj()，输出true \n yxm promise可用于解决异步返回结果时间顺序不可控的问题12345678910111213141516171819202122232425262728293031let fs = require(&apos;fs&apos;);let p1 = new Promise(function(resolve, reject) &#123; fs.readFile(&apos;./file111.txt&apos;, (err, data) =&gt; &#123; if(err) &#123; reject(&apos;错误类型&apos; + err); &#125; else &#123; resolve(data.toString()); &#125; &#125;)&#125;);let p2 = new Promise(function(resolve, reject) &#123; fs.readFile(&apos;./file2.txt&apos;, (err, data) =&gt; &#123; if(err) &#123; reject(err); &#125; else &#123; resolve(data.toString()); &#125; &#125;)&#125;);通过all方法实现p1、p2的输出顺序；当p1、p2之间其中之一出错，全部报错，此处all方法相当于实现了同步处理Promise.all([p1, p2]).then(function(datas) &#123; // console.log(datas); datas.forEach(item =&gt; &#123; console.log(item); &#125;)&#125;, function(errs) &#123; console.log(errs);&#125;); 缓存12345678910// 分配指定内存Buffer.alloc(10);// 返回一个缓存，并容纳数据Buffer.from(string, encoding); // 读取缓存buf.toString([encoding[, start[, end]]]);// 写入缓存buf.write(str);// 复制缓存2到缓存1buf1.copy(buf2); fs1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556let fs = require('fs');// 读取数据fs.readFile('./6.js', (err, data) =&gt; &#123; if (err) throw err; console.log(data.toString());&#125;)// 写入数据let str = '&lt;h1&gt;hello world&lt;/h1&gt;'fs.writeFile('./file.txt', str, err =&gt; &#123; if (err) throw err; console.log('文件写入成功');&#125;);fs.stat('./file.txt', (err, stats) =&gt; &#123; if (err) throw err; console.log(stats.isFile());&#125;);let readStream = fs.createReadStream('./file.txt');let writeStream = fs.createWriteStream('./file1.txt');let writeStream1 = fs.createWriteStream('./file1.txt.zip');let writeStream2 = fs.createWriteStream('./file11.txt');let zlib = require('zlib');// 管道读写，输出流.pipe(输入流)readStream.pipe(writeStream);//压缩，链式流readStream.pipe(zlib.createGzip()) .on('error', (err) =&gt; &#123; throw err; &#125;) .pipe(writeStream1) .on('error', (err) =&gt; &#123; throw err; &#125;);// 解压// 读入流可监听data、error、end事件// 写入流（最后需执行stream.end()）可监听finish、error事件fs.createReadStream('file1.txt.zip') .pipe(zlib.createGunzip()) .on('error', (err) =&gt; &#123; throw err; &#125;) .pipe(writeStream2) .on('error', (err) =&gt; &#123; throw err; &#125;);// 删除文件fs.unlink(path, (err) =&gt; &#123;&#125;) 拓展，删除文件夹data123456789101112131415161718192021let fs = require('fs');function delDir(p) &#123; let fileLists = fs.readdirSync(p); // 遍历当前文件夹下的文件和文件夹 for(var i in fileLists) &#123; let path = p + '/' + fileLists[i]; let info = fs.statSync(path); if(info.isFile()) &#123; fs.unlinkSync(path); &#125; else &#123; arguments.callee(path); &#125; &#125; // 删除空文件夹 fs.rmdirSync(p);&#125;delDir('./data'); path路径方法12345678910let path = require(&apos;path&apos;);let p1 = &apos;../../././hello/../sm/h.html&apos;;console.log(p1);console.log(path.normalize(p1));console.log(path.join(__dirname, p1)); // 重点console.log(path.dirname(p1)); // 返回路径的文件夹部分console.log(path.basename(p1)); // 返回路径的文件部分(文件名+扩展名)console.log(path.extname(p1)); // 返回路径的扩展名， 用于文件上传限制path.parse(p1) // 重点方法返回一个对象,包括属性root、dir、 base、 name、 ext url完整结构协议://用户名:密码@主机名.名.域:端口号/目录名/文件名.扩展名?参数名=参数值#hashhttp常见结构协议://主机名.名.域/目录名/文件名.扩展名?参数名=参数值#hash12345678910let u = 'https://ke.qq.com/webcourse/index.html?q=what&amp;name=yxm#cid=315597'// 老式Url解析let url = require('url');console.log(url.parse(u));// 新式解析let uObj = new URL(u);console.log(uObj);console.log(uObj.searchParams.get('q')); http因为大多数请求都是 GET 请求且不带请求主体，所以 Node.js 提供了该便捷方法。 该方法与 http.request() 唯一的区别是它设置请求方法为 GET 且自动调用 req.end()。callback 被调用时只传入一个参数，该参数是 http.IncomingMessage 的一个实例。123456789let http = require('http');let fs = require('fs');http.get('http://www.baidu.com', (res) =&gt; &#123; res.on('data', data =&gt; &#123; console.log(data.toString()); &#125;); res.pipe(fs.createWriteStream('./baidu.html'));&#125;); 创建服务器123456789101112131415let http = require('http');let url =require('url');let util = require('util');http.createServer((req, res) =&gt; &#123; // console.log(req); res.writeHead(200, &#123;'Content-Type': 'text/plain; charset=utf-8'&#125;); // 以字节流的方式发送，可多次write res.write(util.inspect(new URL('http://127.0.0.1' + req.url))); console.log(req.url); // 标志流结束，浏览器/客户端停止加载 res.end(util.inspect(url.parse(req.url, true)));&#125;).listen(8080, ()=&gt; &#123; console.log('服务器已启动');&#125;); 状态码点击菜鸟教程状态码使用res.writeHead(状态码， 响应头对象); 响应头处理跨域, 指匹配所有地址，可指定某一地址res.writeHead(200, { ‘Content-Type’: ‘text/plain; charset=utf-8’, ‘Access-Control-Allow-Origin’ : ‘‘}); 常见的MIME类型 超文本标记语言文本 .html text/htmlxml文档 .xml text/xmlXHTML文档 .xhtml application/xhtml+xml普通文本 .txt text/plainRTF文本 .rtf application/rtfPDF文档 .pdf application/pdfMicrosoft Word文件 .word application/mswordPNG图像 .png image/pngGIF图形 .gif image/gifJPEG图形 .jpeg,.jpg image/jpegau声音文件 .au audio/basicMIDI音乐文件 mid,.midi audio/midi,audio/x-midiRealAudio音乐文件 .ra, .ram audio/x-pn-realaudioMPEG文件 .mpg,.mpeg video/mpegAVI文件 .avi video/x-msvideoGZIP文件 .gz application/x-gzipTAR文件 .tar application/x-tar get请求处理参数12345678http.createServer((req, res) =&gt; &#123; let obj = new URL('http://127.0.0.1' + req.url); res.writeHead(200, &#123;'Content-Type': 'text/plain; charset=utf-8'&#125;); res.write('名字是： ' + obj.searchParams.get('name') + '\n'); res.end(obj.search);&#125;).listen(8080, ()=&gt; &#123; console.log('服务器已启动');&#125;); POST请求123456789101112131415161718192021222324252627&lt;!DOCTYPE html&gt;&lt;html&gt;&lt;head&gt; &lt;meta charset="utf-8"&gt; &lt;title&gt;首页&lt;/title&gt; &lt;link href='/css/index.css' rel="stylesheet" type="text/css"&gt;&lt;/head&gt;&lt;body&gt; &lt;nav&gt; &lt;a href="https://www.baidu.com/"&gt;百度&lt;/a&gt; &lt;a href="https://www.baidu.com/"&gt;百度&lt;/a&gt; &lt;/nav&gt; &lt;h1&gt;杨晓东杨翔铭肥麦英公别&lt;/h1&gt; &lt;video width="100%" controls="controls"&gt; &lt;source src="https://vdept.bdstatic.com/554243654b5356764e6e5168336c5742/3371664459366e53/6c3caa603467efb66b3bc8a1febfe131fc3c80c331807873acefd2c5b05689e6d5b99ae40c03c0bbda366123a8c6063f.mp4?auth_key=1580917714-0-0-7fc61bcbba0643fcca03d79b83928198" type="video/mp4" /&gt; &lt;/video&gt; &lt;img src="/img/logo.png" alt="百度logo"&gt; &lt;form method="POST" action="/action.html" enctype="multipart/form-data"&gt; &lt;label for="name"&gt;姓名：&lt;/label&gt; &lt;input type="text" name="name" id="name"&gt;&lt;br&gt; &lt;label for="pwd"&gt;密码：&lt;/label&gt; &lt;input type="text" name="pwd" id="pwd"&gt;&lt;br&gt; &lt;input type="file" name="img" multiple&gt;&lt;br&gt; &lt;button type="submit"&gt;确定&lt;/button&gt; &lt;/form&gt;&lt;/body&gt;&lt;/html&gt; 123456789101112131415161718192021222324252627282930313233343536373839404142let http = require('http');let fs = require('fs');let path = require('path');// let querystring = require('querystring');http.createServer((req, res) =&gt; &#123; if(req.url === '/') &#123; req.url = '/src/index.html'; &#125; else if(req.url === '/action.html') &#123; let body = ''; req.on('data', chunk =&gt; &#123; body += chunk.toString(); &#125;); req.on('end', () =&gt; &#123; console.log(body); // body = querystring.parse(body); res.writeHead(200, &#123;'Content-type' : 'text/html; charset=utf-8'&#125;); // res.write('姓名'+body.name); // res.write("&lt;br&gt;"); // res.write('密码'+body.pwd); res.write('接受到数据：' + body); res.end(); &#125;); return; &#125; let ext = path.parse(req.url).ext; let extList = &#123;'.css':'text/css', '.html' : 'text/html', '.png':'image/png'&#125;; // console.log(ext, req.url); fs.readFile('.' + req.url, (err, data) =&gt; &#123; if(err) &#123; res.writeHead(404, &#123;'content-type' : 'text/html; charset=utf-8'&#125;); res.write('资源找不到'); &#125; else &#123; res.writeHead(200, &#123;'Content-type' : extList[ext] + ';charset=utf-8'&#125;); res.write(data); &#125; res.end(); &#125;);&#125;).listen(8081, err =&gt; &#123; if(err) throw err; console.log('服务器已启动');&#125;); 网络ipconfig 查看ip地址ipconfig -all 查看所有地址，包括DNS服务器地址win7以上版本可在C:\Windows\System32\drivers\etc目录下修改host文件，指定dns解析，如 127.0.0.1 www.seasonin.github.ioping 因特网包探索器，用于测试网络连接量的程序。netstat 是在内核中访问网络连接状态及其相关信息的程序，它能提供TCP连接，TCP和UDP监听，进程内存管理的相关报告。netstat -a 列出所有当前的连接；-ab 查看程序使用端口情况， -t 列出tcp连接，- u 列出udp连接， -n 选项禁用域名解析功能， -l 选项列出正在监听的套接字， -p 选项查看进程信息, -e 用于显示关于以太网的统计数据。它列出的项目包括传送的数据报的总字节数、错误数、删除数、数据报的数量和广播的数量… express安装express-generatornpm install express-generator -g添加ejs 模板引擎express -e send方法res.send();不能直接发送数字，会认为是状态码send方法只能执行一次，因为包含了res.end()，重复出现会报错链式调用，发送状态码和数据 res.status(200).send(data); 其他方法详见express官方apires.json(data)res.render(‘视图’, ‘数据’); // 使用模板渲染返回数据res.download(‘文件’, ‘重命名文件’); //下载指定路径下的文件，并重命名，第二个参数可选res.redirect([status,] path) //重定向，跳转其他链接res.cookie(name, value [, options]) // 设置cookie req.query,req.bodyreq.params.name, 获取/user/:name的那么值 中间件是一个函数，常见app.use((req, res, next) =&gt; {}) 和app.method（如app.get()）, 位于客户端与路由之间，可访问请求对象和响应对象、调起下一中间件，处理中间数据express是一个由中间件构建起来的框架 中间件使用，写一个记录用户登录日志的中间件，next用于调起下一中间件1234567891011app.use((req, res, next) =&gt; &#123; let fs = require('fs'); let ip = req.ip; let time = new Date().toLocaleString(); let data = fs.readFileSync('./login.log'); data += 'ip: ' + ip + ' 时间： ' + time +'\n'; fs.writeFileSync('./login.log', data); next();&#125;);]]></content>
      <tags>
        <tag>node.js</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[crossDomain]]></title>
    <url>%2FmarkdownBlog.github.io%2F2019%2F12%2F20%2FcrossDomain%2F</url>
    <content type="text"><![CDATA[跨域： 请求不同源的资源同源： 协议+域名+端口相同同源策略，防止浏览器受到XSS、CSFR等攻击 跨域的解决方案： 通过jsonp跨域 document.domain + iframe跨域 location.hash + iframe window.name + iframe跨域 postMessage跨域 跨域资源共享（CORS） nginx代理跨域 nodejs中间件代理跨域 WebSocket协议跨域 jsonp跨域浏览器允许html页面加载不同域下的静态资源（js、css、img）。动态创建script，指定src，执行回调函数。可兼容旧的浏览器，但只能是get请求不支持post请求。123456789101112131415161718&lt;script&gt; var script = document.createElement('script'); // script.type = 'text/javascript'; // 传参一个回调函数名给后端，方便后端返回时执行这个在前端定义的回调函数 script.src = 'http://www.domain2.com:8080/login?user=admin&amp;callback=handleCallback'; // document.head.appendChild(script); document.body.appendChild(script); // 回调执行函数 function handleCallback(res) &#123; alert(JSON.stringify(res)); &#125;&lt;/script&gt;// 服务器返回内容// handleCallback(&#123;"status": true, "user": "admin"&#125;) 12345678910111213141516// jquery$.ajax(&#123; url: &apos;http://www.domain2.com:8080/login&apos;, type: &apos;get&apos;, dataType: &apos;jsonp&apos;, // 请求方式为jsonp jsonpCallback: &quot;handleCallback&quot;, // 自定义回调函数名 data: &#123;&#125;&#125;);// vue.jsthis.$http.jsonp(&apos;http://www.domain2.com:8080/login&apos;, &#123; params: &#123;&#125;, jsonp: &apos;handleCallback&apos;&#125;).then((res) =&gt; &#123; console.log(res); &#125;) document.domain+iframe跨域主域相同，子域不同。通过设置document.domain为相同的域名，实现同域（document.domain的设置是有限制的，我们只能把document.domain设置成自身或更高一级的父域，且主域必须相同。）。1234567891011121314// 父窗口(http://www.domain.com/a.html)&lt;iframe id=&quot;iframe&quot; src=&quot;http://child.domain.com/b.html&quot;&gt;&lt;/iframe&gt;&lt;script&gt; // 设置 document.domain = &apos;domain.com&apos;; var user = &apos;admin&apos;;&lt;/script&gt;// 子窗口(http://child.domain.com/b.html)&lt;script&gt; document.domain = &apos;domain.com&apos;; // 获取父窗口中变量 alert(&apos;get js data from parent ---&gt; &apos; + window.parent.user);&lt;/script&gt; location.hash + iframe跨域两个页面不在同一个域下IE、Chrome不允许修改parent.location.hash的值，因此借助于父窗口域名下的一个代理iframea.html传送数据到b.html，b.html监听到url发生变化，触发相应操作b.html通过hash传送数据给c.html，c.html监听到url变化，修改父域名的hash值。123456789101112131415161718192021222324252627282930313233343536373839// a.html(http://www.domain1.com/a.html)&lt;iframe id=&quot;iframe&quot; src=&quot;http://www.domain2.com/b.html&quot; style=&quot;display:none;&quot;&gt;&lt;/iframe&gt;&lt;script&gt; var iframe = document.getElementById(&apos;iframe&apos;); // 向b.html传hash值 setTimeout(function() &#123; iframe.src = iframe.src + &apos;#user=admin&apos;; &#125;, 1000); // 开放给同域c.html的回调方法 function onCallback(res) &#123; alert(&apos;data from c.html ---&gt; &apos; + res); &#125;&lt;/script&gt;//b.html：(http://www.domain2.com/b.html)&lt;iframe id=&quot;iframe&quot; src=&quot;http://www.domain1.com/c.html&quot; style=&quot;display:none;&quot;&gt;&lt;/iframe&gt;&lt;script&gt; var iframe = document.getElementById(&apos;iframe&apos;); // 监听a.html传来的hash值，再传给c.html window.onhashchange = function () &#123; iframe.src = iframe.src + location.hash; &#125;;&lt;/script&gt;// c.html：(http://www.domain1.com/c.html)&lt;script&gt; // 监听b.html传来的hash值 window.onhashchange = function () &#123; // 再通过操作同域a.html的js回调，将结果传回 window.parent.parent.onCallback(&apos;hello: &apos; + location.hash.replace(&apos;#user=&apos;, &apos;&apos;)); //因为parent.parent（即http://www.domain1.com/a.html）和http://www.domain1.com/c.html属于同一个域，所以可以改变其location.hash的值 // parent.parent.location.hash = self.location.hash.substring(1); &#125;;&lt;/script&gt; window.name+iframe跨域window.name]]></content>
      <tags>
        <tag>跨域</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[pick]]></title>
    <url>%2FmarkdownBlog.github.io%2F2019%2F10%2F12%2Fpick%2F</url>
    <content type="text"><![CDATA[不稳定的算法：快选希堆稳定的算法：冒插归基 基于UDP的协议DNS，SNMP，DHCP，RIP（路由选择协议），BOOTP（是DHCP的前身），TFTP（简单文件传输协议） 基于TCP的协议HTTP/HTTPS，Telnet，FTP，SMTP，POP3 CSS选择器的优先级如果是处于同一层级，那么下面的css样式会覆盖上面的css样式。!important 特殊性最高 &gt; 内联样式1000 &gt; ID选择器100 &gt; 类选择器10 = 属性选择器 = 伪类选择器 &gt; 元素选择器1 = 关系选择器 = 伪元素选择器 &gt; 通配符选择器0 this指向箭头函数，this对象指向调用函数的对象，全局环境中执行函数this对象指向Window，外层代码块的thisthis指的是函数运行时所在的环境（指向调用函数的对象），全局环境中执行函数this对象指向Window在call和apply函数中this指向指定的对象，如果指定的对为undefined或者null，那么this对象指向Window1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071//例子1function A() &#123;console.log(this)&#125;A();//在全局中调用，指向Window//例子2var b = &#123;getThis:function()&#123; console.log(this)&#125;&#125;b.getThis()//作为对象方法调用，this指向调用该方法的对象b//例子3var c = &#123;getFunc:function()&#123; return function()&#123; console.log(this) &#125;&#125;&#125;var cFun = c.getFunc()cFun()//c.getFunc()返回的是一个匿名函数，匿名函数赋值给cFun，在全局环境中调用了cFun()，this指向全局Window//例子4var c = &#123; getFunc:function()&#123; var that = this //执行c.getFunc()时，this对象指向的还是c，在这里保留住this到that return function()&#123; console.log(that) &#125; &#125;&#125;var cFun = c.getFunc()cFun()//c//例子5var d = &#123; getThis:function()&#123; console.log(this) &#125;&#125;var e = &#123; name:'e'&#125;d.getThis.call(e)//e//例子6var d = &#123; getThis:function()&#123; console.log(this) &#125;&#125; d.getThis.call(null)//Window d.getThis.call(undefined)//Window //例子7var g = &#123; getThis:function()&#123; return function()&#123;console.log(this)&#125; &#125;&#125;var h = &#123; // 此层调用getThis，故getThis里面的this指向h getThis:function()&#123; return ()=&gt; console.log(this) &#125;&#125;g.getThis()()//Windowh.getThis()()//h flex布局容器默认存在两根轴：水平的主轴（main axis）和垂直的交叉轴（cross axis）。 flex-direction属性决定主轴的方向（即项目的排列方向）。由下往上，由上往下，由左往右，由右往左flex-direction: row | row-reverse | column | column-reverse; flex-wrap属性定义，如果一条轴线排不下，如何换行。不换行，换行，换行，第一行在下方。flex-wrap: nowrap | wrap | wrap-reverse; flex-flow属性是flex-direction属性和flex-wrap属性的简写形式，默认值为row nowrapflex-flow: || ; justify-content属性定义了项目在主轴上的对齐方式左对齐，右对齐，居中，两端对齐、项目之间的间隔都相等，每个项目两侧的间隔相等。所以，项目之间的间隔比项目与边框的间隔大一倍。justify-content: flex-start | flex-end | center | space-between | space-around; align-items属性定义项目在交叉轴（纵轴）上如何对齐flex-start：交叉轴的起点对齐。flex-end：交叉轴的终点对齐。center：交叉轴的中点对齐。baseline: 项目的第一行文字的基线对齐。stretch（默认值）：如果项目未设置高度或设为auto，将占满整个容器的高度。align-items: flex-start | flex-end | center | baseline | stretch; align-content属性定义了多根轴线的对齐方式。如果项目只有一根轴线，该属性不起作用flex-start：与交叉轴的起点对齐。flex-end：与交叉轴的终点对齐。center：与交叉轴的中点对齐。space-between：与交叉轴两端对齐，轴线之间的间隔平均分布。space-around：每根轴线两侧的间隔都相等。所以，轴线之间的间隔比轴线与边框的间隔大一倍。stretch（默认值）：轴线占满整个交叉轴。align-content: flex-start | flex-end | center | space-between | space-around | stretch; flex-grow属性定义项目的放大比例，默认为0，即如果存在剩余空间，也不放大。flex-grow: ; / default 0 / flex-shrink属性定义了项目的缩小比例，默认为1，即如果空间不足，该项目将缩小。如果所有项目的flex-shrink属性都为1，当空间不足时，都将等比例缩小。如果一个项目的flex-shrink属性为0，其他项目都为1，则空间不足时，前者不缩小。 flex-basis属性定义了在分配多余空间之前，项目占据的主轴空间（main size）。浏览器根据这个属性，计算主轴是否有多余空间。它的默认值为auto，即项目的本来大小。 flex属性是flex-grow, flex-shrink 和 flex-basis的简写，默认值为0 1 auto。后两个属性可选。]]></content>
  </entry>
  <entry>
    <title><![CDATA[ProfessionalJs]]></title>
    <url>%2FmarkdownBlog.github.io%2F2019%2F09%2F29%2FProfessionalJs%2F</url>
    <content type="text"><![CDATA[元素defer，脚本在整个页面解析完后再运行 async，异步加载脚本，立即下载，同时加载页面其他内容 parseInt(‘10’, 2) // 10的二进制转换成十进制，结果为2num.toString(radix)，十进制转换成radix进制，radix取值范围[2~36]把m进制转换成n进制，parseInt(num, m).toString(n)；]]></content>
      <tags>
        <tag>高级程序设计学习记录</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[copy]]></title>
    <url>%2FmarkdownBlog.github.io%2F2019%2F09%2F29%2Fcopy%2F</url>
    <content type="text"><![CDATA[js的变量类型（1）基本类型：5种基本数据类型Undefined、Null、Boolean、Number 和 String，变量是直接按值存放的，存放在栈内存中的简单数据段，可以直接访问。 （2）引用类型：栈(stack)：先进后出；自动分配内存空间，由系统自动释放；使用的是一级缓存，他们通常都是被调用时处于存储空间中，调用完立即释放。堆(heap)：队列优先，先进先出；动态分配内存，大小不定也不会自动释放；存放在二级缓存中，生命周期由虚拟机的垃圾回收算法来决定；一般由程序员分配释放，若程序员不释放，程序结束时可能由OS回收。基本类型：存放在栈内存中的简单数据段，数据大小确定，内存空间大小可以分配。 Undefined / Null / Boolean / Number / String，它们是直接按值存放的，可以直接访问。引用类型：存放在堆内存中的对象；每个空间大小不一样，根据情况进行特定的分配。当我们需要访问引用数据类型 (对象 / 数组 / 函数) 的值时，首先从栈中获得该对象的地址指针，然后再从堆内存中取得所需的数据。 存放在堆内存中的对象，变量保存的是一个指针，这个指针指向另一个位置。当需要访问引用类型（如对象，数组等）的值时，首先从栈中获得该对象的地址指针，然后再从堆内存中取得所需的数据。JavaScript存储对象都是存地址的，所以浅拷贝会导致 obj1 和obj2 指向同一块内存地址。改变了其中一方的内容，都是在原来的内存上做修改会导致拷贝对象和源对象都发生改变，而深拷贝是开辟一块新的内存地址，将原对象的各个属性逐个复制进去。对拷贝对象和源对象各自的操作互不影响。 （3）实现方法 浅拷贝，直接赋值、Object.assign()只有一层数据，无嵌套对象或数组，arr使用slice或concat方法看起来像深拷贝，但仍然是浅拷贝。 123456789var array = [1, [1,2,3], &#123;name:"array"&#125;]; var array_concat = array.concat();var array_slice = array.slice(0);array_concat[1][0] = 5; //改变array_concat中数组元素的值 console.log(array[1]); //[5,2,3] console.log(array_slice[1]); //[5,2,3] array_slice[2].name = "array_slice"; //改变array_slice中对象元素的值 console.log(array[2].name); //array_sliceconsole.log(array_concat[2].name); //array_slice 深拷贝JSON.parse(JSON.stringify(source))JSON对象parse方法可以将JSON字符串反序列化成JS对象，stringify方法可以将JS对象序列化成JSON字符串 12345var source = &#123; name:"source", child:&#123; name:"child" &#125; &#125; var target = JSON.parse(JSON.stringify(source));target.name = "target"; //改变target的name属性console.log(source.name); //source console.log(target.name); //target 12345678910111213141516var deepCopy = function(obj) &#123; // 只拷贝对象 if(typeof obj !== 'object') return; // 根据obj的类型判断是新建一个数组还是一个对象 var newObj = obj instanceof Array ? [] : &#123;&#125;; // 遍历obj,并且判断是obj的属性才拷贝 for(var key in obj) &#123; // 指示对象自身属性中是否具有指定的属性（也就是，是否有指定的键），忽略掉继承属性（如toString、hasOwnProperty），不会去查找它的原型链 if(obj.hasOwnProperty(key)) &#123; // 判断属性值的类型，如果是对象递归调用深拷贝 newObj[key] = typeof obj[key] === 'object' ? deepCopy(obj[key]) : obj[key]; // 此处若为浅拷贝，这newObj[key] = obj[key]; &#125; &#125; return newObj;&#125;]]></content>
      <tags>
        <tag>浅拷贝和深拷贝</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[reflowAndRepaint]]></title>
    <url>%2FmarkdownBlog.github.io%2F2019%2F09%2F19%2FreflowAndRepaint%2F</url>
    <content type="text"><![CDATA[概念回流：重新对DOM树进行渲染，当render tree中的一部分(或全部)因为元素的规模尺寸，布局，隐藏等改变而需要重新构建。渲染树和DOM树有点像，但是是有区别的。DOM树完全和html标签一一对应，但是渲染树会忽略掉不需要渲染的元素，比如head、display:none的元素重绘：一些元素需要更新属性，而这些属性只是影响元素的外观，风格，而不会影响布局的，如改变了背景颜色、文字颜色、边框颜色、vidibility、outline 触发reflow1：改变窗口大小 2：改变文字大小 3：内容的改变，如文本改变或者图片大小改变而引起的计算值宽度和高度改变 4：激活伪类，如:hover 5：操作class属性 6：脚本操作DOM 7：计算offsetWidth和offsetHeight 8：设置 display: none;（重排并重绘） 或者 visibility: hidden（只有重排） 9： 移动、增加、删除页面中可见的DOM元素 元素位置，尺寸改变——边距、填充、边框、宽度和高度，设置style的值 优化，避免回流 CSS中的定位、隐藏，使用position：absolute/fixed定位；或者是display：none，使之脱离文档流后进行操作，操作完成后再进入到文档流之中。通过 display: none 来隐藏节点（直接导致一次重排和重绘），做大量的修改，然后显示节点（又一次重排和重绘），总共只会有两次重排。 123456789101112131415161718192021222324252627282930313233// 不好的代码function updateAllAnchors(element, anchorClass) &#123; var anchors = element.getElementsByTagName("tr"); for (var i = 0, length = anchors.length; i &lt; length; i ++) &#123; anchors[i].className = anchorClass; // 一直重排、回流 &#125;&#125;// 优化代码// 首先把表格删除，放到DOM树外部操作function removeToInsertLater(element) &#123; var parentNode = element.parentNode; var nextSibling = element.nextSibling; parentNode.removeChild(element); // 或设置element.style.display = "none"; return function() &#123; if (nextSibling) &#123; parentNode.insertBefore(element, nextSibling); &#125; else &#123; parentNode.appendChild(element); &#125; &#125;&#125;//然后调用它function updateAllAnchors(element, anchorClass) &#123; var insertFunction = removeToInsertLater(element); var anchors = element.getElementsByTagName("a"); for (var i = 0, length = anchors.length; i &lt; length; i ++) &#123; anchors[i].className = anchorClass; &#125; insertFunction();&#125; 通过class统一设置样式，避免使用document.element.style.prototype来意义改变。不要立即做操作，而是批量进行。比如把脚本对DOM的修改放入一个队列，在队列所有操作结束后只需要进行一次绘制即可。 不要用tables布局的另一个原因就是tables中某个元素一旦触发reflow就会导致table里所有的其它元素reflow。在适合用table的场合，可以设置table-layout为auto或fixed，使得table一行一行渲染 css里不要有表达式expression 避免不必要的复杂的 CSS 选择器，尤其是后代选择器（descendant selectors），因为为了匹配选择器将耗费更多的 CPU。 尽量不要过多的频繁的去增加，修改，删除元素，因为这可能会频繁的导致页面reflow，可以先把该dom节点抽离到内存中进行复杂的操作然后再display到页面上。 请求如下值offsetTop, offsetLeft, offsetWidth, offsetHeight，scrollTop/Left/Width/Height，clientTop/Left/Width/Height，浏览器会发生reflow。需要经常取那些引起浏览器重排的属性值时，要缓存到变量，减少回流次数。]]></content>
      <tags>
        <tag>回流(重排)和重绘</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[debounceAndThrottle]]></title>
    <url>%2FmarkdownBlog.github.io%2F2019%2F09%2F19%2FdebounceAndThrottle%2F</url>
    <content type="text"><![CDATA[持续触发，如resize、scroll、mousemove1234567891011121314151617181920212223&lt;!--以下为持续mousemove事件--&gt;&lt;div id="content" style="height:150px;line-height:150px;text-align:center; color: #fff;background-color:#ccc;font-size:80px;"&gt;&lt;/div&gt;&lt;script&gt; let num = 1; let content = document.getElementById('content'); function count() &#123; content.innerHTML = num++; &#125;; content.onmousemove = count;&lt;/script&gt;&lt;!--持续输入事件，模拟ajax--&gt;&lt;input type="text" name="inputText" id="inputText"&gt;&lt;script&gt; function ajax(content) &#123; console.log('ajax request' + content); &#125; document.getElementById('inputText').addEventListener('keyup', function(e) &#123; ajax(e.target.value) &#125;)&lt;/script&gt; 为解决资源上的浪费，采用函数防抖和节流 函数防抖触发事件后在 n 秒内函数只能执行一次，如果在 n 秒内又触发了事件，则会重新计算函数执行时间。栗子：持续触发scroll事件时，并不执行handle函数，当1000毫秒内没有触发scroll事件时，才会延时触发scroll事件。应用场景：search搜索联想，用户在不断输入值时，用防抖来节约请求资源。window触发resize的时候，不断的调整浏览器窗口大小会不断的触发这个事件，用防抖来让其只触发一次 12345678910111213141516171819202122232425262728293031323334353637383940414243444546/** * @desc 函数防抖 * @param func 函数 * @param wait 延迟执行毫秒数 * @param immediate true 表立即执行，false 表非立即执行 * 非立即执行版的意思是触发事件后函数不会立即执行，而是在 n 秒后执行，如果在 n 秒内又触发了事件，则会重新计算函数执行时间。 * 立即执行版的意思是触发事件后函数会立即执行，然后 n 秒内不触发事件才能继续执行函数的效果。 * arguments 是一个对应于传递给函数的参数的类数组对象，引用着函数的实参，类似于Array，但除了length属性和索引元素之外没有任何Array属性。 */function debounce(func,wait,immediate) &#123; let timeout; return function () &#123; let context = this; let args = arguments; if (timeout) clearTimeout(timeout); if (immediate) &#123; var callNow = !timeout; timeout = setTimeout(() =&gt; &#123; timeout = null; &#125;, wait) if (callNow) func.apply(context, args) &#125; else &#123; timeout = setTimeout(function()&#123; func.apply(context, args) &#125;, wait); &#125; &#125;&#125;// 另一版本的非立即执行防抖function debounce(fn, wait) &#123; var timeout = null; return function() &#123; if(timeout !== null) clearTimeout(timeout); timeout = setTimeout(fn, wait); &#125;&#125;// 处理函数function handle() &#123; console.log(Math.random()); &#125;// 滚动事件window.addEventListener('scroll', debounce(handle, 1000)); 函数节流当持续触发事件时，保证一定时间段内只调用一次事件处理函数。栗子：持续触发scroll事件时，并不立即执行handle函数，每隔1000毫秒才会执行一次handle函数。 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869// 时间戳var throttle = function(func, delay) &#123; var prev = Date.now(); return function() &#123; var context = this; var args = arguments; var now = Date.now(); if (now - prev &gt;= delay) &#123; func.apply(context, args); prev = Date.now(); &#125; &#125; &#125; function handle() &#123; console.log(Math.random()); &#125; window.addEventListener('scroll', throttle(handle, 1000));// 定时器var throttle = function(func, delay) &#123; var timer = null; return function() &#123; var context = this; var args = arguments; if (!timer) &#123; timer = setTimeout(function() &#123; func.apply(context, args); timer = null; &#125;, delay); &#125; &#125; &#125; function handle() &#123; console.log(Math.random()); &#125; window.addEventListener('scroll', throttle(handle, 1000));/** * @desc 函数节流 * @param func 函数 * @param wait 延迟执行毫秒数 * @param type 1 表时间戳版，2 表定时器版 */function throttle(func, wait ,type) &#123; if(type===1)&#123; let previous = 0; &#125;else if(type===2)&#123; let timeout; &#125; return function() &#123; let context = this; let args = arguments; if(type===1)&#123; let now = Date.now(); if (now - previous &gt; wait) &#123; func.apply(context, args); previous = now; &#125; &#125;else if(type===2)&#123; if (!timeout) &#123; timeout = setTimeout(() =&gt; &#123; timeout = null; func.apply(context, args) &#125;, wait) &#125; &#125; &#125;&#125; 区别： 函数节流不管事件触发有多频繁，都会保证在规定时间内一定会执行一次真正的事件处理函数，而函数防抖只是在最后一次事件后才触发一次函数。]]></content>
      <tags>
        <tag>防抖和节流</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[cookieAndSession]]></title>
    <url>%2FmarkdownBlog.github.io%2F2019%2F09%2F16%2FcookieAndSession%2F</url>
    <content type="text"><![CDATA[session与cookie区别http是一个不保存状态的协议，什么叫不保存状态，就是一个服务器是不清楚是不是同一个浏览器在访问他，所以有了cookie的出现cookie放在浏览器，是客户端保存用户信息的一种机制，用来记录用户的一些信息；session数据放在服务器，用来跟踪用户的状态，这个数据可以保存在集群、数据库、文件中cookie放在本地不安全session在一定时间保存在服务器，但当访问增多时，会占用服务器性能cookie保存的是字符串，session保存的是对象session不区分路径，cookie区分路径，同一网站不同路径的cookie互相是访问不到的，session可在任何地方访问利用cookie自动填上用户名和密码 localStorage，sessionStorage和cookie的区别cookie数据始终在同源的http请求中携带（即使不需要），即cookie在浏览器和服务器间来回传递。cookie数据还有路径（path）的概念，可以限制cookie只属于某个路径下sessionStorage和localStorage不会自动把数据发送给服务器，仅在本地保存。 存储大小限制也不同，cookie数据不能超过4K，同时因为每次http请求都会携带cookie、所以cookie只适合保存很小的数据，如会话标识。sessionStorage和localStorage虽然也有存储大小的限制，但比cookie大得多，可以达到5M或更大。 sessionStorage不在不同的浏览器窗口中共享，即使是同一个页面；localstorage在所有同源窗口中都是共享的；也就是说只要浏览器不关闭，数据仍然存在cookie: 也是在所有同源窗口中都是共享的.也就是说只要浏览器不关闭，数据仍然存在 cookie使用使用 document.cookie 属性来创建 、读取、及删除 cookie设置过期时间，path参数告诉浏览器cookie的路径，默认cookie属于当前页面document.cookie=”userName=sessionIn; expires=Thu, 18 Dec 2019 12:00:00 GMT; path=/“;删除cookie把有效期改为过去 SessionStorage 和 localStorage用法sessionStorage.keyName=’value’;localStorage.getItem(keyName); //获取指定key的本地存储的值//或者var keyName=localStorage.keyName;sessionStorage.removeItem(keyName); // 删除指定ke的本地存储的值sessionStorage.clear() //清除所有localStorage数据 cookie详解Cookie有大小限制以及浏览器在存cookie的个数也有限制 cookie不能跨域 不能在不同的域名下用，每个cookie都会绑定单一的域名在百度下输入一下命令12javascript:document.cookie=&apos;myname=laihuamin;path=/;domain=.baidu.com&apos;;javascript:document.cookie=&apos;myname=huaminlai;path=/;domain=.google.com&apos;; cookie 的属性 name唯一，表示一个cookie value每个cookie拥有的一个属性，它表示cookie的值 domaincookie绑定的域名，自动绑定到执行语句的当前域 pathpath这个属性默认是’/‘// 默认路径www.baidu.com// blog路径www.baidu.com/blog cookie的有效期expires属性 secure安全标志，指定后，只有在使用SSL链接时候才能发送到服务器，如果是http链接则不会传递该信息。就算设置了secure 属性也并不代表他人不能看到你机器本地保存的 cookie 信息，所以不要把重要信息放cookie就对了 HttpOnly这个属性设置为true，就不能通过js脚本来获取cookie的值，能有效的防止xss攻击 服务器设置cookiesetCookie方法]]></content>
      <tags>
        <tag>cookieAndSession</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[seo]]></title>
    <url>%2FmarkdownBlog.github.io%2F2019%2F09%2F16%2Fseo%2F</url>
    <content type="text"><![CDATA[浅谈SEO 网站结构层次简单，一般中小型网站目录结构不要超过三级 网站首页链接适量，适量的桥可让“蜘蛛”继续往下爬到内页，尽量让“蜘蛛”跳转3次就可到达任何一个内页。但网站连接过多也不好，会影响用户体验 导航优化。导航采用文字，也可搭配图片导航，&lt;img&gt;标签必须添加alt和title属性。每一个页面添加面包屑 页面头部：logo及主导航，以及用户的信息。页面主体：左边正文，包括面包屑导航及正文；右边放热门文章及相关文章，好处：留住访客，让访客多停留，对“蜘蛛”而言，这些文章属于相关链接，增强了页面相关性，也能增强页面的权重。页面底部：版权信息和友情链接。 重要的内容放在最前 控制页面大小，减少http请求，提高网站加载速度 title标题，强调重点，关键词放在最前面，尽量做到每一个页面的title不设置相同的内容 meta keywords 标签，列出几个页面的重要关键词 description 标签，高度概括页面内容，切勿过于冗余 a 标签，加title属性以说明；img标签使用alt属性加以说明；表格使用caption表格标题Yang Xin Ming 作品导航 语法化书写HTML代码，h1-h6用于标题类,nav标签设置主导航，列表使用ul或ol，重要文字用strong 重要内容应放在HTML里不要使用js输出，因为蜘蛛不会读取JS里面的内容 尽量少使用iframe框架，蜘蛛一般不读取其中的内容 谨慎使用 display：none ：对于不想显示的文字内容，应当设置z-index或缩进设置成足够大的负数偏离出浏览器之外。因为搜索引擎会过滤掉display:none其中的内容。 减少http请求数量，合并css和js，采用懒加载，css放在头部，js放在底部，使用外联的css和js 减少DOM操作 图标使用IconFont 压缩代码、图片]]></content>
      <tags>
        <tag>seo优化</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[reviewJs]]></title>
    <url>%2FmarkdownBlog.github.io%2F2019%2F08%2F04%2FreviewJs%2F</url>
    <content type="text"><![CDATA[Js输出 使用 window.alert() 写入警告框使用 document.write() 写入 HTML 输出使用 innerHTML 写入 HTML 元素使用 console.log() 写入浏览器控制台 1234document.getElementById("demo").innerHTML = 5 + 6;document.write(5 + 6);window.alert(5 + 6);console.log(5 + 6); js比较符 123456== 等于=== 等值等型!= 不相等!== 不等值或不等型typeof 返回变量的类型。 =&gt; typeof 2 typeof function () &#123;&#125; instanceof 返回 true，如果对象是对象类型的实例。 js运算 123456789var z = x ** 2 //算x得2次幂var z = Math.pow(x, 2)2 ** 2 ** 3; // 256， 右结合，从右至左计算超大或超小的数值可以用科学计数法来写：实例var y = 123e5; // 12300000var z = 123e-5; // 0.00123 HTML事件 123456onchange HTML 元素已被改变onclick 用户点击了 HTML 元素onmouseover 用户把鼠标移动到 HTML 元素上onmouseout 用户把鼠标移开 HTML 元素onkeydown 用户按下键盘按键onload 浏览器已经完成页面加载 \ 转义字符 var x = &quot;中国是瓷器的故乡，因此 china 与\&quot;China（中国）\&quot;同名。&quot; JavaScript 字符串方法 检索字符串1234567891011121314indexOf()，从零计算位置计算，返回字符串中指定文本首次出现的索引var str = &quot;The full name of China is the People&apos;s Republic of China.&quot;;var pos = str.indexOf(&quot;China&quot;);lastIndexOf()，从零计算位置计算，返回字符串中指定文本最后出现的索引var str = &quot;The full name of China is the People&apos;s Republic of China.&quot;;var pos = str.lastIndexOf(&quot;China&quot;);如果未找到文本， indexOf() 和 lastIndexOf() 均返回 -1。两种方法都接受作为检索起始位置的第二个参数。pos = str.indexOf(&apos;china&apos;, 18)search() 返回字符串中指定文本第一次出现的位置；方法无法设置第二个开始位置参数；可设置更强大的搜索值（正则表达式）。str.search(&apos;china&apos;) 提取部分字符串slice(start, end)从开始到结尾截取字符串，不包括结尾符。如果省略第二个参数，则该方法将裁剪字符串的剩余部分： substring(start, end)类似slice()，不同之处在于 substring() 无法接受负的索引。 substr(start, length)类似于 slice()，不同之处在于第二个参数规定被提取部分的长度。123var str = &quot;Apple, Banana, Mango&quot;;var res = str.slice(7,13);var res = str.slice(-13,-7); // 从结尾开始计数 提取字符串字符charAt() 方法返回字符串中指定下标的字符charCodeAt() 方法返回字符串中指定索引的字符的 ascii 编码String.fromCharCode(num) 把 ascii 编码转换成字符&quot;hello&quot;.charAt(1) //返回e 替换字符串内容replace() 方法用另一个值替换在字符串中指定的值,只替换首个匹配12345678str = &quot;Please visit Microsoft and Microsoft!&quot;;var n = str.replace(&quot;Microsoft&quot;, &quot;W3School&quot;);replace() 对大小写敏感，如需执行大小写不敏感的替换，请使用正则表达式 /ivar n = str.replace(/MICROSOFT/i, &quot;W3School&quot;);如需替换所有匹配，请使用正则表达式的 g 标志（用于全局搜索）var n = str.replace(/Microsoft/g, &quot;W3School&quot;); 转换为大写和小写toUpperCase() 把字符串转换为大写，toLowerCase() 把字符串转换为小写&quot;Hello World!&quot;.toUpperCase() concat() 连接两个或多个字符串123var text1 = &quot;Hello&quot;;var text2 = &quot;World&quot;;text3 = text1.concat(&quot; &quot;, text2, &quot;!&quot;); trim() 方法删除字符串两端的空白符&quot; Hello World! &quot;.trim() 把字符串转换为数组split() 将字符串转换为数组如果省略分隔符，被返回的数组将包含 index [0] 中的整个字符串。 如果分隔符是 “”，被返回的数组将是间隔单个字符的数组“Hello”.split(“”) // 分隔为字符1234var txt = &quot;a,b,c,d,e&quot;; // 字符串txt.split(&quot;,&quot;); // 用逗号分隔txt.split(&quot; &quot;); // 用空格分隔txt.split(&quot;|&quot;); // 用竖线分隔 数值 typeof运算符typeof “Bill” // 返回 “string”typeof 314 // 返回 “number”typeof undefined // 返回 “undefined”typeof 运算符把对象、数组或 null 返回 object注：可通过Object.prototype.toString.call(null)等判断对象，解决弊端typeof function myFunc(){} // 返回 “function” Infinity （或 -Infinity）是 JavaScript 在计算数时超出最大可能数范围时返回的值NaN - 非数值 对象无法进行对比： 对象无法比较var x = new Number(500);var y = new Number(500);// (x == y) 为 false toString() 以字符串返回数值valueOf() 以数值返回数值(100 + 23).valueOf(); // 从表达式 100 + 23 返回 123 Number() 返回数字，由其参数转换而来。Number(false); // 返回 0Number(new Date(“2019-04-15”)); // 返回 1506729600000 parseFloat() 解析其参数并返回浮点数。parseInt() 解析其参数并返回整数。 NaN非数据类型语法，Number.NaN，如 let month = Number.NaN。typeof NaN // numberisNaN(parseInt(‘abc123456’)) // trueisNaN(parseInt(‘12abc’)) // false 字符串和数字进行比较 字符串为非纯数字时,则将非数字字符串转成数字的时候会转换为NaN,当NaN和数字比较时不论大小都返回falseconsole.log(11 &lt; ‘FlyElephant’， 11 &gt; ‘FlyElephant’); //false false NumberObject.toFixed(num)// Number四舍五入为指定小数的数字 数组 Array.foreach() 遍历数组元素添加数组元素var fruits = [“Banana”, “Orange”, “Apple”, “Mango”];fruits.push(“Lemon”); // 向 fruits 添加一个新元素 (Lemon) pop() 方法从数组中删除最后一个元素fruits.pop(); // 从 fruits 删除最后一个元素（”Mango”） 把数组转换为字符串document.getElementById(“demo”).innerHTML = fruits.toString(); // Banana,Orange,Apple,Mango join() 方法也可将所有数组元素结合为一个字符串。它的行为类似 toString()，但是您还可以规定分隔符fruits.join(“ “); // Banana Orange Apple Mango 位移元素shift() 方法会删除首个数组元素，并把所有其他元素“位移”到更低的索引。fruits.shift(); // 从 fruits 删除第一个元素 “Banana” 拼接数组第一个参数（2）定义了应添加新元素的位置（拼接），第二个参数（0）定义应删除多少元素。fruits.splice(2, 2, “Lemon”, “Kiwi”); // [“Banana”, “Orange”, “Lemon”, “Kiwi”] concat() 方法通过合并（连接）现有数组来创建一个新数组fruits.concat([“Lemon”, “Kiwi”]) push() 和 concat()的区别push() 方法可向数组的末尾添加一个或多个元素，并返回新的长度。 12var a = [1,2,3,4];a.push(5); //a 现在是1,2,3,4,5 concat() 方法用于连接两个或多个数组。该方法不会改变现有的数组，而仅仅会返回被连接数组的一个副本。 123var a = [1,2,3,4];var b = [5,6];var c = a.concat(b); // a,b 数组都不变，c变成了1,2,3,4,5,6 裁剪数组slice() 方法用数组的某个片段切出新数组。从开始参数选取元素，直到结束参数（不包括）为止；如果结束参数被省略，则 slice() 会切出数组的剩余部分 sort() 方法以字母顺序对数组进行排序按照字符串顺序对值进行排序比较函数应该返回一个负，零或正值，这取决于参var points = [40, 100, 1, 5, 25, 10];points.sort(function(a, b){return a - b}); 以随机顺序排序数组points.sort(function(){return 0.5 - Math.random()}); reverse() 方法反转数组中的元素fruits.sort(); // 对 fruits 中的元素进行排序，Apple Banana,,Mango,Orangefruits.reverse(); // 反转元素，Orange,Mango,Banana,Apple 对数组使用 Math.max()您可以使用 Math.max.apply 来查找数组中的最高值：Math.max.apply([1, 2, 3]) 等于 Math.max(1, 2, 3)Math.min.apply([1, 2, 3]) 等于 Math.min(1, 2, 3) 数组迭代方法Array.forEach()forEach() 方法为每个数组元素调用一次函数该函数接受 3 个参数：项目值项目索引数组本身 1234567var num = [1, 2, 3]var text = ''num.forEach(function(value) &#123; text+= value + '&lt;br&gt;';&#125;);console.log(text); // 1&lt;br&gt;2&lt;br&gt;3&lt;br&gt; Array.map()map() 方法通过对每个数组元素执行函数来创建新数组。map() 方法不会对没有值的数组元素执行函数。map() 方法不会更改原始数组 123456var numbers1 = [45, 4, 9, 16, 25];var numbers2 = numbers1.map(myFunction);function myFunction(value, index, array) &#123; return value * 2;&#125; Array.filter()filter() 方法创建一个包含通过测试的数组元素的新数组。123456var numbers = [45, 4, 9, 16, 25];var over18 = numbers.filter(myFunction);function myFunction(value, index, array) &#123; return value &gt; 18;&#125; Array.reduce(callback,[initialValue])reduce 为数组中的每一个元素依次执行回调函数，不包括数组中被删除或从未被赋值的元素，接受四个参数：初始值（或者上一次回调函数的返回值），当前元素值，当前索引，调用 reduce 的数组。1234567891011121314151617181920212223242526272829303132333435363738var arr = [1, 2, 3, 4];var sum = arr.reduce(function(prev, cur, index, arr) &#123; console.log(prev, cur, index); return prev + cur;&#125;, 0)console.log(arr, sum);// 打印结果// 0 1 0// 1 2 1// 3 3 2// 6 4 3// [1, 2, 3, 4] 10// 计算数组中每个元素出现的次数let names = ['Alice', 'Bob', 'Tiff', 'Bruce', 'Alice'];let nameNum = names.reduce((pre,cur)=&gt;&#123; if(cur in pre)&#123; pre[cur]++ &#125;else&#123; pre[cur] = 1 &#125; return pre&#125;,&#123;&#125;)console.log(nameNum); //&#123;Alice: 2, Bob: 1, Tiff: 1, Bruce: 1&#125;// 数组去重let arr = [2, 4, 2, 4, 3, 1];let newArr = arr.reduce(function(pre, cur) &#123; if(!pre.includes(cur)) &#123; return pre.concat(cur); &#125; else &#123; return pre; &#125;&#125;, [])console.log(newArr); Array.every()every() 方法检查所有数组值是否通过测试。 这个例子检查所有数组值是否大于 18123456var numbers = [45, 4, 9, 16, 25];var allOver18 = numbers.every(myFunction); // falsefunction myFunction(value, index, array) &#123; return value &gt; 18;&#125; Array.some()some() 方法检查某些数组值是否通过了测试。 这个例子检查某些数组值是否大于 18 123456var numbers = [45, 4, 9, 16, 25];var someOver18 = numbers.some(myFunction); // truefunction myFunction(value, index, array) &#123; return value &gt; 18; &#125; Array.find()find() 方法返回通过测试函数的第一个数组元素的值，否则返回undefined 这个例子查找（返回）大于 18 的第一个元素的值 123456var numbers = [4, 9, 16, 25, 29];var first = numbers.find(myFunction); // 25function myFunction(value, index, array) &#123; return value &gt; 18;&#125; Array.findIndex()findIndex() 方法返回通过测试函数的第一个数组元素的索引，否则返回-1 日期new Date()，返回日期创建日期，var d = new Date(2019, 12, 3, 6, 40, 50, 0)，按照年月日时分秒毫秒的顺序创建新的日期对象也可var d = new Date(“2018-3-20T12:00:00”)，以时、分和秒 (YYYY-MM-DDTHH:MM:SS)的形式创建日期 JavaScript Math 对象Math.PI // 返回 3.141592653589793Math.round(x) 的返回值是 x 四舍五入为最接近的整数Math.pow(x, y) 的返回值是 x 的 y 次幂Math.sqrt(x) 返回 x 的平方根Math.abs(x) 返回 x 的绝对（正）值Math.ceil(x) 的返回值是 x 上舍入最接近的整数, Math.ceil(6.4) // 7Math.floor(x) 的返回值是 x 下舍入最接近的整数Math.sin(x) 返回角 x（以弧度计）的正弦（介于 -1 与 1 之间的值） Math.sin(90 * Math.PI / 180); // 返回 1（90 度的正弦）Math.cos(x) 返回角 x（以弧度计）的余弦（介于 -1 与 1 之间的值）Math.min() 和 Math.max() 可用于查找参数列表中的最低或最高值 Math.min(0, 450, 35, 10, -8, -300, -78); // 返回 -300Math.random() 返回介于 0（包括） 与 1（不包括） 之间的随机数 返回介于 min（包括）和 max（不包括）之间的随机数123function getRndInteger(min, max) &#123; return Math.floor(Math.random() * (max - min) ) + min;&#125; switch(表达式) { case n: 代码块 break; case n: 代码块 break; default: 默认代码块} continue 语句（不论有无标签引用）只能用于跳过一个迭代。 break 语句，如果没有标签引用，只能用于跳出一个循环或一个 switch。 如果有标签引用，则 break 语句可用于跳出任意代码块： 12345678910111213var cars = ["BMW", "Volvo", "porsche", "Ford"];var text = "";list: &#123; text += cars[0] + "&lt;br&gt;"; text += cars[1] + "&lt;br&gt;"; break list; text += cars[2] + "&lt;br&gt;"; text += cars[3] + "&lt;br&gt;"; &#125;// text: BMW Volvo constructor 属性constructor 属性返回所有 JavaScript 变量的构造器函数“Bill”.constructor // 返回 “function String() { [native code] }”(3.14).constructor // 返回 “function Number() { [native code] }”false.constructor // 返回 “function Boolean() { [native code] }”[1,2,3,4].constructor // 返回 “function Array() { [native code] }”{name:’Bill’, age:62}.constructor // 返回” function Object() { [native code] }”new Date().constructor // 返回 “function Date() { [native code] }”function () {}.constructor // 返回 “function Function(){ [native code] }” 123// 判断 myArray是否为数组return myArray.constructor.toString().indexOf("Array") &gt; -1;return myArray.constructor === Array; 正则表达式/pattern（模式）/modifiers（修饰符）; search() 方法使用表达式来搜索匹配，然后返回匹配的位置。12'hellow Yxm Yxm'.search('Yxm'); // 7'hellow yxm Yxm'.search(/Yxm/i); // 7 replace() 方法返回模式被替换处修改后的字符串。1234var str = "Visit Microsoft!";var res = str.replace(/microsoft/i, "W3School"); // res === 'Visit W3School!''hello yxm Yxm'.replace(/yxm/gi, 'gkh'); // "hello gkh gkh" 正则表达式修饰符i 执行对大小写不敏感的匹配。g 执行全局匹配（查找所有匹配而非在找到第一个匹配后停止）。m 执行多行匹配。 test()通过模式来搜索字符串，然后根据结果返回 true 或 false。/\d/g.test(‘sadfdsa123456’) //true exec() 它通过指定的模式（pattern）搜索字符串，并返回一个结果数组，否则返回 null。/e/.exec(“The best things in life are free!”);console.log(/(yxm)/.exec(‘a student named yxm’)); // [“yxm”, “yxm”, index: 16, input: “a student named yxm”, groups: undefined] match() 方法可在字符串内检索指定的值，或找到一个或多个正则表达式的匹配，否则返回 null。该方法类似 indexOf() 和 lastIndexOf()，但是它返回一个数组，其中存放了与它找到的匹配文本有关的信息，而不是字符串的位置。1234'Hello world'.match(/world/);// ["world", index: 6, input: "Hello world", groups: undefined]'Hello world World'.match(/world/ig);// ["world", "World"] 使用prototype属性向对象构造器添加新属性1234567function Person(first, last, age, eyecolor) &#123; this.firstName = first; this.lastName = last; this.age = age; this.eyeColor = eyecolor;&#125;Person.prototype.nationality = "English"; arguments 对象JavaScript 函数有一个名为 arguments 对象的内置对象。arguments 对象包含函数调用时使用的参数数组。这样，您就可以简单地使用函数来查找（例如）数字列表中的最高值：实例12345678910111213x = findMax(1, 123, 500, 115, 44, 88);function findMax() &#123; var i; var max = -Infinity; console.log(arguments); // arguments.length，返回参数数目 for (i = 0; i &lt; arguments.length; i++) &#123; if (arguments[i] &gt; max) &#123; max = arguments[i]; &#125; &#125; return max;&#125; 自执行函数只调用函数，不被调用的情况下自动执行123(function () &#123; var x = 'hello';&#125;)(); js call()方法通过call，可以使用另一对象apply与call相似，apply接受数组中的参数在特定的作用域中调用函数，设置函数体内this对象的值，以扩充函数赖以运行的作用域。12345678910111213141516171819202122var person1 = &#123; fistName: '杨', lastName: '过'&#125;var person = &#123; fullName: function(city, country) &#123; return this.fistName + this.lastName + city + country; &#125;&#125;console.log(person.fullName.call(person1, 'guangzhou', 'china')); //杨过guangzhouchinaconsole.log(person.fullName.apply(person1, ['guangzhou', 'china'])); //杨过guangzhou, chinaMath.max.apply(null, [1,2,3]); // 遍历数组的最大值，返回3// call() 和 apply() 是预定义的函数方法。 两个方法可用于调用函数，两个方法的第一个参数必须是对象本身。var myObject;function myFunction(a, b) &#123; return a * b;&#125;myObject = myFunction.call(myObject, 10, 2); // 返回 20document.getElementById("demo").innerHTML = myObject; DOM修改属性、样式document.getElementById(id).attribute = new value修改HTML属性的值document.getElementById(‘myImage’).src = ‘car.jpg’ document.getElementById(id).style.property = new style修改元素样式document.getElementById(“p2”).style.color = “blue”; 如果您需要查找匹配指定 CSS 选择器（id、类名、类型、属性、属性值等等）的所有 HTML 元素，请使用 querySelectorAll() 方法。var x = document.querySelectorAll(“p.intro”); 如使用 getElementsByClassName() 方法，某些浏览器会返回 NodeList 对象而不是 HTMLCollection。所有浏览器都会为 childNodes 属性返回 NodeList 对象。大多数浏览器会为 querySelectorAll() 方法返回 NodeList 对象。NodeList 中的元素可通过索引号进行访问。y = myNodeList[1]; DOM事件onclickonload, onunload，用户进入或离开页面后触发，用于检测访问者的浏览器类型和浏览器版本，然后基于该信息加载网页的恰当版本。onchangeonmouseover, onmouseout，鼠标移至 HTML 元素上或移出时触发鼠标按钮被点击时，onmousedown 事件被触发；然后当鼠标按钮被释放时，onmouseup 事件被触发；最后，当鼠标点击完成后，onclick 事件被触发onfocus，获得焦点时触发 element.addEventListener(event, function, useCapture)，第三个参数是布尔值，指定使用事件冒泡还是事件捕获默认值是 false，将使用冒泡传播（由内向外处理时间），如果该值设置为 true，则事件使用捕获传播（由外向内处理事件）。element.addEventListener(event, function)123window.addEventListener("resize", function()&#123; document.getElementById("demo").innerHTML = window.innerWidth;&#125;); 节点导航 所有子节点（包括包括文本节点、注释节点即回车、换行、空格、文本等等）parentNodechildrenNodes[nodenumber]firstChildlastChildnextSiblingpreviousSibling children 返回元素子节点（元素节点）firstElementChild 返回第一个子节点（元素节点）lastElementChild 返回最后一个子节点（元素节点）parentElement 父节点（元素节点）nextElementSibling 返回元素的上一个兄弟元素节点（不包括文本节点、注释节点）previousElementSibling 返回元素的下一个兄弟元素节点（不包括文本节点、注释节点） 传递参数当传递参数值时，请以参数形式使用调用指定函数的“匿名函数”：element.addEventListener(“click”, function(){ myFunction(p1, p2); }); element.removeEventListener(“mousemove”, myFunction); HTML元素节点createElementcreateTextNodeappendChildinsertBeforeremoveChild1234567891011121314151617&lt;div id="div1"&gt;&lt;p id="p1"&gt;这是一个段落。&lt;/p&gt;&lt;p id="p2"&gt;这是另一个段落。&lt;/p&gt;&lt;/div&gt;&lt;script&gt;var para = document.createElement("p");var node = document.createTextNode("这是新文本。");para.appendChild(node);var element = document.getElementById("div1");element.appendChild(para);var p1 = document.getElementById('p1')element.insertBefore(para, p1);element.removeChild(document.getElementById('p2'));element.replaceChild(para, p1);&lt;/script&gt; window窗口浏览器窗口（浏览器视口）不包括工具栏和滚动条。window.innerHeight - 浏览器窗口的内高度（以像素计）window.innerWidth - 浏览器窗口的内宽度（以像素计）window.open() - 打开新窗口window.close() - 关闭当前窗口window.moveTo() -移动当前窗口window.resizeTo() -重新调整当前窗口 window locationwindow.location.href 当前页面的 href (URL)window.location.hostname web 主机的域名window.location.pathname 当前页面的路径或文件名window.location.protocol 使用的 web 协议（http: 或 https:）window.location.assign() 加载新文档 window.location.assign(“https://www.baidu.com&quot;)window.location.search 请求的参数window.location.hash 设置或获取 href 属性中在井号“#”后面的分段。 window History对象window.history.back() 加载历史列表中前一个 URLwindow.history.forward() 加载历史列表中下一个 URL history.go()：接受一个整数作为参数，以当前网址为基准，移动到参数指定的网址。如果参数超过实际存在的网址范围，该方法无效果；如果不指定参数，默认参数为0，相当于刷新当前页面。history.go(0)相当于刷新当前页面。history.go(1)相当于history.forward()，返回下一页history.go(-1)相当于history.back()，返回上一页 Navigator对象 txt = "浏览器代号: " + navigator.appCodeName + ""; txt+= "浏览器名称: " + navigator.appName + ""; txt+= "浏览器版本: " + navigator.appVersion + ""; txt+= "启用Cookies: " + navigator.cookieEnabled + ""; txt+= "硬件平台: " + navigator.platform + ""; txt+= "用户代理: " + navigator.userAgent + ""; txt+= "用户代理语言: " + navigator.systemLanguage + ""; document.getElementById("example").innerHTML=txt; 弹窗确认框 window.confirm(“sometext”);var r = confirm(“请按按钮”);if (r == true) { x = “您按了确认！”;} else { x = “您按了取消！”;} 计时事件setInterval(“javascript function”,milliseconds) - 间隔指定的毫秒数不停地执行指定的代码。clearInterval(intervalVariable)setTimeout(“javascript function”,milliseconds) - 在指定的毫秒数后执行指定代码。clearTimeout(timeoutVariable) cookie1.创建cookiedocument.cookie = “username=Bill Gates; expires=Sun, 31 Dec 2017 12:00:00 UTC; path=/“;2.删除cookiedocument.cookie = “username=; expires=Thu, 01 Jan 1970 00:00:00 UTC; path=/;”; canvas123&lt;canvas id="myCanvas" width="200" height="100"style="border:1px solid #000000;"&gt;&lt;/canvas&gt; 画矩形1234var c=document.getElementById("myCanvas");var ctx=c.getContext("2d"); // 创建context对象，拥有多种绘制路径、矩形、圆形、字符以及添加图像的方法。ctx.fillStyle="#FF0000"; // 染成红色ctx.fillRect(0,0,150,75); // 从x、y坐标起画长、宽矩形 画线条12345var c=document.getElementById("myCanvas");var ctx=c.getContext("2d");ctx.moveTo(0,0); // 定义线条开始坐标ctx.lineTo(200,100); // 定义线条结束坐标ctx.stroke(); // 使用到 "ink" 的方法来绘制线条 画圆形，arc(x,y,r,start,stop)12345var c=document.getElementById("myCanvas");var ctx=c.getContext("2d");ctx.beginPath();ctx.arc(95,50,40,0,2*Math.PI);ctx.stroke(); 画文本12345var c=document.getElementById("myCanvas");var ctx=c.getContext("2d");ctx.font="30px Arial";ctx.strokeText("Hello World",10,50); // 空心字ctx.fillText("Hello World",10,20); // 实心字 渐变createLinearGradient(x,y,x1,y1) - 创建线条渐变createRadialGradient(x,y,r,x1,y1,r1) - 创建一个径向/圆渐变123456789101112var c=document.getElementById("myCanvas");var ctx=c.getContext("2d"); // 创建渐变var grd=ctx.createLinearGradient(0,0,200,0);// var grd=ctx.createRadialGradient(75,50,5,90,60,100); grd.addColorStop(0,"red");grd.addColorStop(1,"white"); // 填充渐变ctx.fillStyle=grd;ctx.fillRect(10,10,150,80); 图像12345var c=document.getElementById("myCanvas");var cxt=c.getContext("2d");var img=new Image()img.src="flower.png"cxt.drawImage(img,0,0); JSONJSON.parse(text, callback(key, value))，把文本转换为js对象，把衍生自数组的 JSON 返回 JavaScript 数组12345678910var text = '&#123;"employees":[' +'&#123;"firstName":"Bill","lastName":"Gates" &#125;,' +'&#123;"firstName":"Steve","lastName":"Jobs" &#125;,' +'&#123;"firstName":"Elon","lastName":"Musk" &#125;]&#125;';var obj = text;obj.employees[1].firstNameJSON.parse('[ "porsche", "BMW", "Volvo", "Audi" ])');// "porsche" JSON.stringify()，把js对象转换成字符串12345var obj = &#123; name:"Bill Gates", age:62, city:"Seattle"&#125;;var myJSON = JSON.stringify(obj);document.getElementById("demo").innerHTML = myJSON;JSON.stringify( [ "Bill Gates", "Steve Jobs", "Elon Musk" ]); // "["Bill Gates","Steve Jobs","Elon Musk"]" es6数组模型解构可嵌套1234let [a, [[b], c]] = [1, [[2], 3]];// a = 1// b = 2// c = 3 不完全解构 + 默认值1let [a = 1, b] = []; // a = 1, b = undefined 剩余解构123let [a, ...b] = [1, 2, 3];//a = 1//b = [2, 3] 数组解构基本 + 默认值123let &#123;c, d, f = 3&#125; = &#123;c:1, d:2&#125;;console.log(c, d, f);//1, 2, 3 可嵌套123let &#123;p: [x, &#123;y&#125;]&#125; = &#123;p: ['hello', &#123;y: 'world'&#125;]&#125;;console.log(x, y);// hello world 剩余运算符123let &#123;g, h, ...i&#125; = &#123;g:10, h:8, j:3, k:9&#125;;console.log(g, h, i);// 10 8 &#123; j: 3, k: 9 &#125; Symbol取独一无二的值，用于定义对象唯一属性名1234567let sy = Symbol("KK");console.log(sy); // Symbol(KK)typeof(sy); // "symbol" // 相同参数 Symbol() 返回的值不相等let sy1 = Symbol("kk"); sy === sy1; // false 作为对象的属性名1234567let sy = Symbol("key1"); // 写法1let syObject = &#123;&#125;;syObject[sy] = "kk";console.log(syObject); // &#123;Symbol(key1): "kk"&#125;console.log(syObject[sy]); // kk 定义常量1234567891011121314151617181920212223242526272829303132333435363738// 但是用字符串不能保证常量是独特的，这样会引起一些问题：const COLOR_RED = "red";const COLOR_YELLOW = "yellow";const COLOR_BLUE = "blue";const MY_BLUE = "blue"； function getConstantName(color) &#123; switch (color) &#123; case COLOR_RED : return "COLOR_RED"; case COLOR_YELLOW : return "COLOR_YELLOW "; case COLOR_BLUE: return "COLOR_BLUE"; case MY_BLUE: return "MY_BLUE"; default: throw new Exception('Can't find this color'); &#125;&#125;// 使用 Symbol 定义常量，这样就可以保证这一组常量的值都不相等。const COLOR_RED = Symbol("red");const COLOR_YELLOW = Symbol("yellow");const COLOR_BLUE = Symbol("blue"); function getConstantName(color) &#123; switch (color) &#123; case COLOR_RED : return "COLOR_RED"; case COLOR_YELLOW : return "COLOR_YELLOW "; case COLOR_BLUE: return "COLOR_BLUE"; default: throw new Exception('Can't find this color'); &#125;&#125; Symbol.for()Symbol.for() 类似单例模式，首先会在全局搜索被登记的 Symbol 中是否有该字符串参数作为名称的 Symbol 值，如果有即返回该 Symbol 值，若没有则新建并返回一个以该字符串参数为名称的 Symbol 值，并登记在全局环境中供搜索。123456let yellow = Symbol("Yellow");let yellow1 = Symbol.for("Yellow");yellow === yellow1; // false let yellow2 = Symbol.for("Yellow");yellow1 === yellow2; // true Symbol.keyFor()Symbol.keyFor() 返回一个已登记的 Symbol 类型值的 key ，用来检测该字符串参数作为名称的 Symbol 值是否已被登记。12let yellow1 = Symbol.for("Yellow");Symbol.keyFor(yellow1); // "Yellow" Map 对象保存键值对123456789101112131415161718192021222324252627var myMap = new Map();var key = 'key'; // key 可是字符串、对象、函数、NaNmyMap.set(key, '和key相关的值');myMap.get(key);var keyObj = &#123;&#125;, myMap.set(keyObj, "和键 keyObj 关联的值");var keyFunc = function () &#123;&#125;, // 函数myMap.set(keyFunc, "和键 keyFunc 关联的值");// for...of迭代，遍历Mapfor (var [key, value] of myMap) &#123; console.log(key + " = " + value);&#125;myMap.entries() // 返回Iterator对象myMap.keys() myMap.values()// forEach() myMap.forEach(function(key, value) &#123;console.log(key + " = " + value);&#125;, myMap)// array转换成mapvar myMap = new Map(Array);// map转换成arrayvar arr = Array.from(myMap); set对象Set 对象允许你存储任何类型的唯一值123456789101112131415161718let mySet = new Set();mySet.add(1);mySet.add(5);mySet.add(5);mySet.add('yang');mySet.add(&#123;a:1, b:2&#125;);// &#123;1, 5, "yang", &#123;…&#125;&#125;// array转换成setlet mySet1 = new Set(["value1", "value2", "value3"]);// Set转换成arraylet myArray = [...mySet1];// 数组去重let mySet2 = new Set([1,2,2,3,4,4]);[...mySet2]; // [1, 2, 3, 4]// 此外可实现Set的并、交、差集 ProxyProxy 对目标对象的读取、函数调用等操作进行拦截，然后对操作进行过滤和改写。Proxy就像代理器，代理操作Proxy 对象由两部分组成，target（目标对象）、handler（配置对象，代理操作）。get(target, propKey, receiver),set(target, propKey, value, receiver)receiver一般是Proxy本身1234567891011121314151617181920212223242526let target = &#123; name: 'tom', age: 22, sex: 'man'&#125;let handler = &#123; get : (target, key) =&gt; &#123; console.log('getting $&#123;key&#125;'); return target[key]; &#125;, set : (target, key, value) =&gt; &#123; if(key==='age' &amp;&amp; !/^\d+$/g.test(value)) &#123; // !Number.isInteger(value) throw new Error('年龄不符合') &#125; console.log('setting',key,value); target[key] = value; &#125;&#125;let myProxy = new Proxy(target, handler);console.log(myProxy.name, myProxy.age);myProxy.age=12;console.log(myProxy.name, myProxy.age);myProxy.age='46fdgsfd5'; // 报错 Reflect将 Object 的一些明显属于语言内部的方法移植到了 Reflect 对象上（当前某些方法会同时存在于 Object 和 Reflect 对象上），未来的新方法会只部署在 Reflect 对象上 Reflect.get(target, name, receiver) //查找并返回 target 对象的 name 属性123456789101112131415161718192021let exam = &#123; name: "Tom", age: 24, get info()&#123; return this.name + this.age; &#125;&#125;Reflect.get(exam, 'name'); // "Tom" // 当 target 对象中存在 name 属性的 getter 方法， getter 方法的 this 会绑定 // receiverlet receiver = &#123; name: "Jerry", age: 20&#125;Reflect.get(exam, 'info', receiver); // Jerry20 // 当 name 为不存在于 target 对象的属性时，返回 undefinedReflect.get(exam, 'birth'); // undefined // 当 target 不是对象时，会报错Reflect.get(1, 'name'); // TypeError Reflect.set(target, name, value, receiver)123456789101112131415161718192021222324252627let exam = &#123; name: "Tom", age: 24, set info(value)&#123; return this.age = value; &#125;&#125;exam.age; // 24Reflect.set(exam, 'age', 25); // trueexam.age; // 25 // value 为空时会将 name 属性清除Reflect.set(exam, 'age', ); // trueexam.age; // undefined // 当 target 对象中存在 name 属性 setter 方法时，setter 方法中的 this 会绑定 // receiver , 所以修改的实际上是 receiver 的属性,let receiver = &#123; age: 18&#125;Reflect.set(exam, 'info', 1, receiver); // truereceiver.age; // 1 let receiver1 = &#123; name: 'oppps'&#125;Reflect.set(exam, 'info', 1, receiver1);receiver1.age; // 1 Reflect.has(obj, name) 是 name in obj 指令的函数化，用于查找 name 属性在 obj 对象中是否存在。返回值为 boolean。如果 obj 不是对象则会报错 TypeError。 Reflect.deleteProperty(obj, property) 是 delete obj[property] 的函数化，用于删除 obj 对象的 property 属性，返回值为 boolean。如果 obj 不是对象则会报错 TypeError。 Reflect.apply(func, thisArg, args) 等同于 Function.prototype.apply.call(func, thisArg, args) 。func 表示目标函数；thisArg 表示目标函数绑定的 this 对象；args 表示目标函数调用时传入的参数列表，可以是数组或类似数组的对象。若目标函数无法调用，会抛出 TypeError 。 字符串includes() 返回布尔值，查找是否存在参数startsWith()：返回布尔值，判断参数字符串是否在原字符串的头部。endsWith()：返回布尔值，判断参数字符串是否在原字符串的尾部。repeat(count)：返回新的字符串，表示将字符串重复指定次数返回。count小数，向下取整；NaN，0次。padStart：返回新的字符串，表示用参数字符串从头部（左侧）补全原字符串。padEnd：返回新的字符串，表示用参数字符串从尾部（右侧）补全原字符串。第一个参数是指定生成的字符串的最小长度，第二个参数是用来补全的字符串。1234567891011let string = "apple,banana,orange";string.includes("banana"); // truestring.startsWith("apple"); // truestring.endsWith("apple"); // falsestring.startsWith("banana",6) // trueconsole.log("Hello,".repeat(2)); // "Hello,Hello,"console.log("h".padStart(5,"o")); // "ooooh"console.log("h".padEnd(5,"o")); // "hoooo"console.log("h".padStart(5)); // " h" 模板字符串相当于加强版的字符串，用反引号 `,除了作为普通字符串，还可以用来定义多行字符串，还可以在字符串中加入变量和表达式。123456789101112131415161718192021222324let string = `Hello'\n'world`;console.log(string); // "Hello'// 'world"let string1 = `Hey,can you stop angry now?`;console.log(string1);// Hey,// can you stop angry now?// 变量名写在 $&#123;&#125; 中，$&#123;&#125; 中可以放入 JavaScript 表达式。let name = "Mike";let age = 27;let info = `My Name is $&#123;name&#125;,I am $&#123;age+1&#125; years old next year.`console.log(info);// My Name is Mike,I am 28 years old next year.// 字符串中调用函数：function f()&#123; return "have fun!";&#125;let string2= `Game start,$&#123;f()&#125;`;console.log(string2); // Game start,have fun! 标签模板一个函数的调用，其中调用的参数是模板字符串。1234567891011121314151617181920212223alert`Hello world!`;// 等价于alert('Hello world!');// 当模板字符串中带有变量，会将模板字符串参数处理成多个参数。function f(stringArr,...values)&#123; let result = ""; for(let i=0;i&lt;stringArr.length;i++)&#123; result += stringArr[i]; if(values[i])&#123; result += values[i]; &#125; &#125; return result;&#125;let name = 'Mike';let age = 27;f`My Name is $&#123;name&#125;,I am $&#123;age+1&#125; years old next year.`;// "My Name is Mike,I am 28 years old next year." f`My Name is $&#123;name&#125;,I am $&#123;age+1&#125; years old next year.`;// 等价于f(['My Name is',',I am ',' years old next year.'],'Mike',28); NumberNumber.isFinite() // 判断是否有限Number.isInteger() // 判断是否是数字Number.isSafeInteger() // 判断数值是否在安全范围内Number.parseInt()Number.parseFloat()Math.cbrt() // 平方根Math.imul(1, 2); // 2，大多数情况下，结果与 a * b 相同；两个数以 32 位带符号整数形式相乘的结果，返回的也是一个 32 位的带符号整数。Math.imul(0x7fffffff, 0x7fffffff); // 1， 用于正确返回大数乘法结果中的低位数值Math.hypot(3， 4) // 5， 计算所有参数的平方和的平方根Math.clz32(1) // 31, 用于返回数字的32 位无符号整数形式的前导0的个数。Math.trunc() // 返回数字的整数部分，整数向下取整，负数向上取整Math.fround() // 获取数字的32位单精度浮点数形式Math.sign() // 判断数字的符号（1 -1 0）Math.expm1() // 用于计算 e 的 x 次方减 1 的结果，即 Math.exp(x) - 1Math.log1p(x) // 计算1 + x 的自然对数，即 Math.log(1 + x)Math.log10(x) // 计算以 10 为底的 x 的对数Math.log2() // 计算 2 为底的 x 的对数Math.sinh(x): 用于计算双曲正弦。Math.cosh(x): 用于计算双曲余弦。Math.tanh(x): 用于计算双曲正切。Math.asinh(x): 用于计算反双曲正弦。Math.acosh(x): 用于计算反双曲余弦。Math.atanh(x): 用于计算反双曲正切 对象属性、方法名简写123456789101112131415161718const age = 12;const name = 'yang';let person = &#123; age, name, sayHi() &#123; console.log('hi'); &#125;&#125;// 等同于let person = &#123; age : age, name : name, sayHi : function() &#123; console.log('hi'); &#125;&#125; 属性名表达式ES6允许用表达式作为属性名，但是一定要将表达式放在方括号内123456const obj = &#123; [&quot;he&quot;+&quot;llo&quot;]()&#123; return &quot;Hi&quot;; &#125;&#125;obj.hello(); //&quot;Hi&quot; 对象的拓展运算符拓展运算符（…）用于取出参数对象所有可遍历属性然后拷贝到当前对象。12345678910111213// 基本用法let person = &#123;name: "Amy", age: 15&#125;;let someone = &#123; ...person &#125;;someone; //&#123;name: "Amy", age: 15&#125;// 合并两个对象let age = &#123;age: 15&#125;;let name = &#123;name: "Amy"&#125;;let person = &#123;...age, ...name&#125;;person; //&#123;age: 15, name: "Amy"&#125;someone = &#123;...person, 'age':12&#125; // &#123;age:12, name:'Amy'&#125;后面的相同属性覆盖前面的someone = &#123;'age':12, ...person&#125; // &#123;age:15, name:'Amy'&#125;后面的相同属性覆盖前面的 对象的新方法Object.assign(target, source_1, ···) // 返回值为target用于将源对象的所有可枚举属性复制到目标对象中。1234567891011121314let [target, source1, source2] = [&#123;a:1&#125;, &#123;b:2&#125;, &#123;c:3&#125;];Object.assign(target, source1, source2);target; // &#123;a: 1, b: 2, c: 3&#125;// assign 的属性拷贝是浅拷贝:let sourceObj = &#123; a: &#123; b: 1&#125;&#125;;let targetObj = &#123;c: 3&#125;;Object.assign(targetObj, sourceObj);targetObj.a.b = 2;sourceObj.a.b; // 2// 数组的处理// 先将 [2,3] 转为 &#123;0:2,1:3&#125; ，然后再进行属性复制，所以源对象的 0 号属性覆盖了目标对象的 0Object.assign([2,3], [5]); // [5,3] Object.is(value1, value2)用来比较两个值是否严格相等12345678910Object.is("q","q"); // trueObject.is(1,1); // trueObject.is([1],[1]); // falseObject.is(&#123;q:1&#125;,&#123;q:1&#125;); // false//一是+0不等于-0Object.is(+0,-0); //false+0 === -0 //true//二是NaN等于本身Object.is(NaN,NaN); //trueNaN === NaN //false ArrayArray.of将参数中所有值作为元素形成数组12345console.log(Array.of(1, 2, 3, 4)); // [1, 2, 3, 4]// 参数值可为不同类型console.log(Array.of(1, '2', true)); // [1, '2', true]// 参数为空时返回空数组console.log(Array.of()); // [] Array.from(arrayLike[, mapFn[, thisArg]])arrayLike,想要转换的类数组对象或可迭代对象；mapFn,可选，map 函数，用于对每个元素进行处理，放入数组的是处理后的元素；thisArg，可选，用于指定 map 函数执行时的 this 对象。1234567891011Array.from([1, 2, 3], n =&gt; n*2);let map = &#123; do: function(n) &#123; return n * 2; &#125;&#125;let arrayLike = [1, 2, 3];console.log(Array.from(arrayLike, function (n)&#123; return this.do(n);&#125;, map)); // [2, 4, 6] 类数组对象一个类数组对象必须含有 length 属性，且元素属性名必须是数值或者可转换为数值的字符 1234567891011121314151617181920212223let arr = Array.from(&#123; 0: '1', 1: '2', 2: 3, length: 3&#125;);console.log(); // ['1', '2', 3] // 没有 length 属性,则返回空数组let array = Array.from(&#123; 0: '1', 1: '2', 2: 3,&#125;);console.log(array); // [] // 元素属性名不为数值且无法转换为数值，返回长度为 length 元素值为 undefined 的数组 let array1 = Array.from(&#123; a: 1, b: 2, length: 2&#125;);console.log(array1); // [undefined, undefined] 转换成可迭代对象1234567891011let map = new Map();map.set('key0', 'value0');map.set('key1', 'value1');console.log(Array.from(map)); // [['key0', 'value0'],['key1','value1']]let arr = [1, 2, 3];let set = new Set(arr);console.log(Array.from(set)); // [1, 2, 3]let str = 'abc';console.log(Array.from(str)); // ["a", "b", "c"] 查找find()查找数组中符合条件的元素,若有多个符合条件的元素，则返回第一个元素。findIndex()查找数组中符合条件的元素索引，若有多个符合条件的元素，则返回第一个元素索引。12Array.of('hello', 'world').find(item =&gt; item.match(/^w[\w]+d$/ig)) // worldArray.of(1, 2, 3).findIndex(item =&gt; item===2) // 1 fill() 填充12345let arr = Array.of(1, 2, 3, 4);// 参数1：用来填充的值// 参数2：被填充的起始索引// 参数3(可选)：被填充的结束索引，默认为数组末尾console.log(arr.fill(0,1,2)); // [1, 0, 3, 4] copyWithin()1234567// 参数1：被修改的起始索引// 参数2：被用来覆盖的数据的起始索引// 参数3(可选)：被用来覆盖的数据的结束索引，默认为数组末尾console.log([1, 2, 3, 4].copyWithin(0,2,4)); // [3, 4, 3, 4] // 参数1为负数表示倒数console.log([1, 2, 3, 4].copyWithin(-2, 0)); // [1, 2, 1, 2] 遍历123456789101112131415161718// arr.entries()for(let [key, value] of ['a', 'b'].entries()) &#123; consle.log(key, value);&#125;// 0, a// 1, b['a', 'b'].entries().next().value; // [0, a]// keys()for(let key of ['a', 'b'].keys())&#123; console.log(key);&#125;// values()for(let value of ['a', 'b'].values())&#123; console.log(value);&#125; incluedes1[1, 2, 3].includes(1); 将嵌套数组转为一位数组12345// arr.flat()， 默认转换一层console.log([1, [2, [3, [4, 5]]]].flat(Infinity)); // [1, 2, 3, 4, 5]console.log([1, [2, [3, [4, 5]]]].flat(2)); // [1, 2, 3, [4, 5]]// flatMap(),对数组每个元素进行处理，再flat() 数组缓冲区1234567891011121314151617// 通过构造函数创建:let buffer = new ArrayBuffer(10);console.log(buffer.byteLength); // 10// 视图// 默认 DataView 可操作数组缓冲区全部内容let buffer = new ArrayBuffer(10); dataView = new DataView(buffer); dataView.setInt8(0,1);console.log(dataView.getInt8(0)); // 1 // 通过设定偏移量(参数2)与长度(参数3)指定 DataView 可操作的字节范围let buffer1 = new ArrayBuffer(10); dataView1 = new DataView(buffer1, 0, 3);dataView1.setInt8(5,1); // RangeError// 定型数组 扩展运算符12let arr = [...[1, 2], ...[3, 4]]// [1,2,3,4] 函数默认参数1234567891011function fn(name,age=17)&#123; console.log(name+","+age);&#125;fn("Amy",18); // Amy,18fn("Amy",""); // Amy,fn("Amy"); // Amy,17function f(x,y=x)&#123; console.log(x,y);&#125;f(1); // 1 1 不定参数12let f2 = (...arr) =&gt; console.log(arr);f2(1, 2, 3) // [1, 2, 3] 箭头函数返回对象时，要用()将对象包裹起来，以区分代码块12var f = (id,name) =&gt; (&#123;id: id, name: name&#125;);f(6,2); // &#123;id: 6, name: 2&#125; 注意点：没有 this、super、arguments 和 new.target 绑定。123456var func = () =&gt; &#123; // 箭头函数里面没有 this 对象， // 此时的 this 是外层的 this 对象，即 Window console.log(this)&#125;func(55) // Window 箭头函数体中的 this 对象，是定义函数时的对象，而不是使用函数时的对象。123456789101112131415161718192021222324252627282930313233function fn()&#123; // 此处定义函数，也是箭头函数的外层 setTimeout(()=&gt;&#123; // 定义时，this 绑定的是 fn 中的 this 对象 console.log(this.a); &#125;,0)&#125;var a = 20;// fn 的 this 对象为 &#123;a: 19&#125;fn.call(&#123;a: 18&#125;); // 18// 回调函数var Person = &#123; 'age': 18, 'sayHello': function () &#123; setTimeout(function () &#123; console.log(this.age); &#125;); &#125;&#125;;var age = 20;Person.sayHello(); // 20 var Person1 = &#123; 'age': 18, 'sayHello': function () &#123; setTimeout(()=&gt;&#123; console.log(this.age); &#125;); &#125;&#125;;var age = 20;Person1.sayHello(); // 18 Iterator通过一个键为Symbol.iterator 的方法来访问遍历结构元素的指针1234567891011const items = ["zero", "one", "two"];const it = items[Symbol.iterator](); it.next();&gt;&#123;value: "zero", done: false&#125;it.next();&gt;&#123;value: "one", done: false&#125;it.next();&gt;&#123;value: "two", done: false&#125;it.next();&gt;&#123;value: undefined, done: true&#125; 使用 for…of循环123for(let item of ['a', 'b', 'c']) &#123; console.log(item);&#125; Promise对象异步操作，三种状态，Pending、fulfilled、RejectedPromise接收连个参数，resolve和reject；then方法指定resolve和reject的回调函数。then方法指定的函数将在当前脚本所有同步任务执行完成后才会执行。后续操作。123456789101112131415let p = new Promise(function(resolve, reject) &#123; console.log('Promise'); resolve();&#125;)p.then(function() &#123; console.log('resolve');&#125;);console.log('hi');// 立即执行-同步任务-异步任务// Promise // hi// resolve]]></content>
      <tags>
        <tag>reviewJs</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[wrongSummery]]></title>
    <url>%2FmarkdownBlog.github.io%2F2019%2F05%2F11%2FwrongSummery%2F</url>
    <content type="text"><![CDATA[在公司上班的这段时间，我遇到了不少问题，也总结了许多 span标签跟在a标签后，如果设置a的width为100%，会引起span错位 span标签内若无内容，设置width无效，需加 display: block; 才生效 设置button居中，加 display: block; 和 margin: 0 auto，即设置button为block块 可设置width和padding来间接设置左右边距 bootStrap的container容器可能会影响div块的长度 几张块（如div、img）层叠在一起时可能会导致内层的元素（如button）无法正常使用，需设置好嵌套关系和z-index来解决，z-index设置对比层的同层关系 避免直接命名class为container等框架频繁词，应加上s-等前缀，避免样式冲突等问题 top、left可设置距离外元素的边距。结合translate: transform(x,y)，x、y指本元素左上角距离偏移量。 遵循样式尽量简洁的原则，避免造成样式混乱 a标签的width尽量大，如与其父级的div块同宽，方便用户点击 bootstrap container里面的row会超出左右-15px，可设置margin-left:0和margin-top:0，是row与container同宽 ::before 和 ::after 属性：content，在css渲染中向元素逻辑上的头部或尾部添加内容。这些添加不会出现在DOM中，不会改变文档内容，不可复制，仅仅是在css渲染层加入。 content的值:string；attr()调用当前元素的属性，比如将图片alt提示文字或者链接的href地址显示出来；url()，引用媒体文件；counter() 详细请见：https://www.cnblogs.com/starof/p/4459991.html .设置::before和::after伪类做背景叠加时，可设置z-index，使得伪类元素置上，底部之下，当底部有阴影渲染是不会污染到伪类元素 GET方法，表单提交是被动的（比如搜索引擎查询），并且没有敏感信息，表单数据页面地址栏可见的。POST方法，表单正在更新数据，或者包含敏感信息（例如密码）。POST 的安全性更加，因为在页面地址栏中被提交的数据是不可见的。 box-sizing: content-box | border-box | inherit | unset | initial;center-box, 宽度和高度分别应用到元素的内容框, 在宽度和高度之外绘制元素的内边距和边框。(内宽高+边框宽高)border-box, 为元素指定的任何内边距和边框都将在已设定的宽度和高度内进行绘制, 通过从已设定的宽度和高度分别减去边框和内边距才能得到内容的宽度和高度。（内宽高-边框宽高） js装箱、拆箱装箱，把基本类型转变为对应的对象（引用类型）。12345678910// 隐私封箱let num = 123;num.toFixed(2); // 123.00// 以上代码在后台实际运行为var c = new Number(123);c.toFixed(2);c = null;// 显式封箱let num = new Number(123); 拆箱把对象（引用类型）转换成基本类型。调用ToPrimitive操作，接收两个参数，第一个参数是要转换的对象，第二个参数是PreferredType，即要转换的类型。转换过程：调用valueOf方法，若无则调用toString方法。12345678910111213141516const c = &#123; toString () &#123; console.log('toString'); return 1; &#125;, valueOf () &#123; console.log('valueOf'); return 2; &#125;&#125;; alert(c); // 打印出 toString 并 alert 出 1c + ''; // 先后打印出 valueOf，"2"c + 500; // 先后打印出 valueOf，502+c; // 先后打印出 valueOf，2c * 1; // 先后打印出 valueOf，2]]></content>
      <categories>
        <category>学习</category>
        <category>总结</category>
      </categories>
      <tags>
        <tag>summery</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Vue Summarize Part 1]]></title>
    <url>%2FmarkdownBlog.github.io%2F2019%2F03%2F21%2FlearnVue%2F</url>
    <content type="text"><![CDATA[v-html:输出html内容将在div块内插入html内容1234&lt;div v-html=&quot;template&quot;&gt;&lt;/div&gt;data:&#123; template:&apos;&lt;div&gt;hello template&lt;/div&gt;&apos;&#125; 标签内可绑定属性值，js运算，三目运算，过滤器12345678910111213141516171819202122232425262728293031323334353637383940414243444546&#123;&#123;&#125;&#125;标签&lt;div id=&quot;app&quot;&gt;&#123;&#123; number / 10 &#125;&#125;&#123;&#123; isOK ? &apos;Y&apos; : &apos;N&apos; &#125;&#125;&#123;&#123; text.split(&apos;,&apos;) &#125;&#125;&#123;&#123; time | formateTime &#125;&#125;&lt;/div&gt;&lt;script&gt;var padDate = value =&gt; &#123; return value &lt; 10 ? &apos;0&apos; + value : value;&#125;var app = new Vue(&#123; el: &apos;app&apos;, data: &#123; number: 100, isOK: false, text: &apos;123,456&apos; &#125;, filters: &#123; formatTime: function (value) &#123; //value即为需要过滤的数据 var date = new Date(value) var year = date.getFullYear() var month = padDate(date.getMonth() + 1) var day = padDate(date.getDate()) var hours = padDate(date.getHours()) var minutes = padDate(date.getMinutes()) var seconds = padDate(date.getSeconds()) return year + &apos;-&apos; + month + &apos;-&apos; + day + &apos; &apos; + hours + &apos;:&apos; + minutes + &apos;:&apos; + seconds &#125; &#125;, mounted: function () &#123; // 挂载el后执行 var _this = this this.timer = setInterval(function () &#123; _this.time = new Date() // 修改数据Date &#125;, 1000) &#125;, beforeDestroy () &#123; // 实例销毁之前调用 if (this.timer) &#123; clearInterval(this.timer) &#125; &#125;&#125;)&lt;/script&gt; v-pre:12显示&#123;&#123;&#125;&#125;标签&lt;span v-pre&gt;&#123;&#123;这里的内容不会被编译&#125;&#125;&lt;/span&gt; v-bind:绑定属性，语法糖 :12345678910111213141516171819202122232425262728293031323334&lt;a v-bind:href=&quot;url&quot;&gt;百度&lt;/a&gt;data:&#123; url: &apos;https://www.baidu.com&apos;&#125;绑定class，对象语法和数组语法&lt;div class=&quot;static&quot; v-bind:class=&quot;[&#123; active: isActive, &apos;text-danger&apos;: hasError &#125;, activeClass, errorClass]&quot;&gt;&lt;/div&gt;data: &#123; isActive: true, hasError: false, activeClass: &apos;active&apos;, errorClass: &apos;text-danger&apos;&#125;绑定内联样式&lt;p :style=&quot;[fontStyles, backgroundStyles]&quot;&gt;字体为黄色，大小30px，背景灰色&lt;/p&gt;&lt;script&gt; let fontStyles = &#123; color: &apos;yellow&apos;, fontSize: &apos;30px&apos; &#125; let backgroundStyles = &#123; background: &apos;gray&apos; &#125; data: &#123; fontStyles, backgroundStyles &#125;&lt;/script&gt; v-on:绑定事件，语法糖 @123456&lt;button @click=&quot;add&quot;&gt;加一&lt;/button&gt;methods:&#123; add : function()&#123; this.count++; &#125;&#125; v-model:轻松实现表单输入和应用状态之间的双向绑定12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879808182修饰符v-model.number，仅接受数字输入.trim，自动过滤首尾空白符；.lazy，change时更新内容&lt;div id=&quot;app-6&quot;&gt; &lt;p&gt;&#123;&#123; message &#125;&#125;&lt;/p&gt; &lt;input v-model=&quot;message&quot;&gt;&lt;/div&gt;var app6 = new Vue(&#123; el: &apos;#app-6&apos;, data: &#123; message: &apos;Hello Vue!&apos; &#125;&#125;)多行文本&lt;p style=&quot;white-space: pre-line;&quot;&gt;&#123;&#123; message &#125;&#125;&lt;/p&gt;&lt;br&gt;&lt;textarea v-model=&quot;message&quot; placeholder=&quot;add multiple lines&quot;&gt;&lt;/textarea&gt;复选框&lt;input type=&quot;checkbox&quot; id=&quot;checkbox&quot; v-model=&quot;checked&quot;&gt;&lt;label for=&quot;checkbox&quot;&gt;&#123;&#123; checked &#125;&#125;&lt;/label&gt;多个复选框&lt;div id=&apos;example-3&apos;&gt; &lt;input type=&quot;checkbox&quot; id=&quot;jack&quot; value=&quot;Jack&quot; v-model=&quot;checkedNames&quot;&gt; &lt;label for=&quot;jack&quot;&gt;Jack&lt;/label&gt; &lt;input type=&quot;checkbox&quot; id=&quot;john&quot; value=&quot;John&quot; v-model=&quot;checkedNames&quot;&gt; &lt;label for=&quot;john&quot;&gt;John&lt;/label&gt; &lt;input type=&quot;checkbox&quot; id=&quot;mike&quot; value=&quot;Mike&quot; v-model=&quot;checkedNames&quot;&gt; &lt;label for=&quot;mike&quot;&gt;Mike&lt;/label&gt; &lt;br&gt; &lt;span&gt;Checked names: &#123;&#123; checkedNames &#125;&#125;&lt;/span&gt;&lt;/div&gt;new Vue(&#123; el: &apos;#example-3&apos;, data: &#123; checkedNames: [] &#125;&#125;)单个按钮&lt;div id=&quot;example-4&quot;&gt; &lt;input type=&quot;radio&quot; id=&quot;one&quot; value=&quot;One&quot; v-model=&quot;picked&quot;&gt; &lt;label for=&quot;one&quot;&gt;One&lt;/label&gt; &lt;br&gt; &lt;input type=&quot;radio&quot; id=&quot;two&quot; value=&quot;Two&quot; v-model=&quot;picked&quot;&gt; &lt;label for=&quot;two&quot;&gt;Two&lt;/label&gt; &lt;br&gt; &lt;span&gt;Picked: &#123;&#123; picked &#125;&#125;&lt;/span&gt;&lt;/div&gt;new Vue(&#123; el: &apos;#example-4&apos;, data: &#123; picked: &apos;&apos; &#125;&#125;)选择框&lt;div id=&quot;example-5&quot;&gt; &lt;select v-model=&quot;selected&quot;&gt; &lt;!--multiple属性，多选--&gt; &lt;option v-for=&quot;option in options&quot; v-bind:value=&quot;option.value&quot;&gt; &#123;&#123; option.text &#125;&#125; &lt;/option&gt; &lt;/select&gt; &lt;span&gt;Selected: &#123;&#123; selected &#125;&#125;&lt;/span&gt;&lt;/div&gt;new Vue(&#123; el: &apos;...&apos;, data: &#123; selected: &apos;A&apos;, options: [ &#123; text: &apos;One&apos;, value: &apos;A&apos; &#125;, &#123; text: &apos;Two&apos;, value: &apos;B&apos; &#125;, &#123; text: &apos;Three&apos;, value: &apos;C&apos; &#125; ] &#125;&#125;) 侦听器：watch123456789101112&lt;div&gt;&#123;&#123;msg&#125;&#125;&lt;/div&gt;watch: &#123; msg:function(newVal,oldVal) &#123; console.log(&apos;newVal is: &apos;+newVal); console.log(&apos;oldVal is: &apos;+oldVal); &#125;, another:function(newVal,oldVal) &#123; console.log(&apos;newVal is: &apos;+newVal); console.log(&apos;oldVal is: &apos;+oldVal); &#125; //仅监听一个变量&#125; 计算属性： computed区别watch，computed可以同时监听多个数据，数据联动区别methods，计算属性是基于它们的响应式依赖进行缓存的。只在相关响应式依赖发生改变时它们才会重新求值。methods多次执行，不设置缓存。1234567&lt;div&gt;&#123;&#123;msg1&#125;&#125;&lt;/div&gt;computed: &#123; msg1:function()&#123; return &apos;computed: &apos; + this.msg + &apos;,&apos; + this.another; //监听Vue实例内的两个变量msg和another变量 &#125;&#125; 条件渲染v-if,v-else-if,v-else,v-show123456789101112131415161718192021&lt;div v-if=&quot;count&gt;0&quot;&gt; 判断1：&#123;&#123;count&#125;&#125;&lt;/div&gt;&lt;div v-else-if=&quot;count&lt;=0&amp;&amp;count&gt;-5&quot;&gt; 判断2：&#123;&#123;count&#125;&#125;&lt;/div&gt;&lt;div v-else&gt; 判断3：&#123;&#123;count&#125;&#125;&lt;/div&gt;&lt;div v-show=&quot;bool&quot;&gt; show字段 &lt;/div&gt;&lt;script&gt;var app = new Vue(&#123; el:&apos;#app&apos;, data:&#123; count:0, show:true &#125;&#125;)&lt;/script&gt; 循环列表v-for，:class与样式(:style)绑定123456789101112131415161718&lt;div v-for=&quot;(item, index) in items&quot; :style=&quot;styleMsg&quot; :class=&quot;[&apos;one&apos;,&apos;two&apos;,&#123;&apos;active&apos;:item.age&gt;18&#125;]&quot;&gt; &#123;&#123;item.name&#125;&#125; - &#123;&#123; index &#125;&#125;&lt;/div&gt;styleMsg:&#123; color:&apos;red&apos;, fontSize:&apos;30px&apos;&#125;,items:[ &#123; name:&apos;lili&apos;, age:20 &#125;, &#123; name:&apos;huhu&apos;, age:18 &#125;] 监听子组件事件1234567891011121314&lt;!-- 父组件 --&gt;&lt;!-- 监听enlarge-text事件 --&gt;&lt;blog-post @enlarge-text=&quot;handleText&quot;&gt;&lt;/blog-post&gt;&lt;!-- 父组件的handleText事件 --&gt;handleText: function (data) &#123;postFontSize += data&#125;&lt;!-- 或者通过$event访问data --&gt;&lt;blog-post @enlarge-text=&quot;postFontSize += $event&quot;&gt;&lt;/blog-post&gt;&lt;!-- 子组件 --&gt;通过this.$emit出发父组件&lt;button v-on:click=&quot;$emit(&apos;enlarge-text&apos;， data)&quot;&gt; Enlarge text&lt;/button&gt; 通过slot，父组件向子组件分发内容父组件123456&lt;child-component&gt; &lt;h2 slot=&quot;header&quot;&gt;&lt;/h2&gt; &lt;p&gt;正文内容&lt;/p&gt; &lt;p&gt;正文内容&lt;/p&gt; &lt;div slot=&quot;footer&quot;&gt;底部&lt;/div&gt;&lt;/child-component&gt; 子组件child-component12345&lt;div class=&quot;container&quot;&gt; &lt;div class=&quot;header&quot;&gt;&lt;slot name=&quot;header&quot;&gt;若父组件不插入内容,我将默认显示&lt;/slot&gt;&lt;/div&gt; &lt;div class=&quot;main&quot;&gt;&lt;slot&gt;&lt;/slot&gt;&lt;/div&gt; &lt;div class=&quot;footer&quot;&gt;&lt;slot name=&quot;footer&quot;&gt;&lt;/slot&gt;&lt;/div&gt;&lt;/div&gt; 则渲染为12345678&lt;div class=&quot;container&quot;&gt; &lt;div class=&quot;header&quot;&gt;&lt;h2&gt;若父组件不插入内容,我将默认显示&lt;/h2&gt;&lt;/div&gt; &lt;div class=&quot;main&quot;&gt; &lt;p&gt;正文内容&lt;/p&gt; &lt;p&gt;正文内容&lt;/p&gt; &lt;/div&gt; &lt;div class=&quot;footer&quot;&gt;&lt;div&gt;底部&lt;/div&gt;&lt;/div&gt;&lt;/div&gt; HTML 中的特性名是大小写不敏感的，所以浏览器会把所有大写字符解释为小写字符。当在 HTML 中使用大写字母时， DOM 中的模板需转换为小写字母。当 HTML 使用kebab-case (短横线分隔命名) 命名时， DOM 中的模板用 camelCase (驼峰命名法)。 vue-cli 全局安装 npm install -g @vue/cli 通过命令行创建一个项目vue create filePath fileNamecd fileNamenpm run serve 运行项目 或者通过图形界面创建一个项目vue ui 运行服务npm run serve 运行整个vue项目vue serve file.vue 运行单个vue文件 初始化项目依赖vue init template-name || webpack project-namecd project-namenpm install 安装项目所需的依赖 几种常用的调试方法 1.console.log()2.console.error()3.alert()4.debugger5.Vue插件6.Network，查看加载的项，查询http请求；调试页面交互，选择阻塞运行，online选项可选择相应的网速7.window.vue = this 代替debugger，console窗口输入window.vue.元素，window对象绑定8.var app = new vue({})，通过app.元素调试，vm实例 storestore/modles/test12345678910111213141516171819202122232425262728293031323334353637383940414243const state = &#123; // 共享的数据 count: 0, list: [1, 2, 25, 63, 18, 50, 30, 20, 13, 8, 63]&#125;const getters = &#123; // 处理computer里面获取到的数据 filterList: state =&gt; &#123; return state.list.filter(item =&gt; item &gt; 20) &#125;&#125;const mutations = &#123; // 改变state里的数据的方法，使用this.$store.commit()调用 increment (state, params) &#123; state.count += params.n &#125;&#125;const actions = &#123; // 处理业务逻辑，异步操作数据，通过$store.dispatch触发 asyncIncrement (context) &#123; return new Promise((resolve, reject) =&gt; &#123; const random = Math.random() console.log(random) if (random &gt; 0.5) &#123; resolve(random) &#125; else &#123; reject(random) &#125; &#125;) &#125;&#125;export default &#123; // 解决不同模块命名冲突的问题 namespaced: true, state, getters, mutations, actions&#125; store/index.js123456export default new Vuex.Store(&#123; modules: &#123; // 模块化，方便检查和使用 test &#125;&#125;) 在其他组件使用12345678910111213141516computed: &#123; ...mapState('test', &#123; // 访问test模块的count数据 count: state =&gt; state.count &#125;), ...mapGetters('test', &#123; // 利用getter过滤数据 list: 'filterList' &#125;)&#125;,methods: &#123; ...mapMutations('test', &#123; // 调用test模块的increment方法，监听按钮的@click="handleIncreCount(&#123;n: 5&#125;)"即可调用 handleIncreCout: 'increment' &#125;)&#125;]]></content>
      <categories>
        <category>学习</category>
        <category>Vue</category>
      </categories>
      <tags>
        <tag>Vue</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[learnLinux]]></title>
    <url>%2FmarkdownBlog.github.io%2F2019%2F03%2F20%2FlearnLinux%2F</url>
    <content type="text"><![CDATA[ls [-adl]：列出目录 -a ：全部的文件，连同隐藏档( 开头为 . 的文件) 一起列出来-d ：仅列出目录本身，而不是列出目录内的文件数据-l ：长数据串列出，包含文件的属性与权限等等数据 cd: 切换目录 cd filenamecd ~ 切换到/root目录cd.. 切换到上一级目录 pwd [-P]: 显示当前[确实完整的]目录 mkdir [-mp]: 创建一个新的目录 m 配置目录权限p 将目录(包含上一级目录)递归创建 rmdir [-p]: 删除一个空的目录 p连同上级目录一起删除 cp (source) (destination): 复制文件或目录 rm [-fir]: 移除文件或目录 -f ：就是 force 的意思，忽略不存在的文件，不会出现警告信息；-i ：互动模式，在删除前会询问使用者是否动作-r ：递归删除,危险的选项！ mv [-fiu] source destination: 移动文件与目录，或修改文件与目录的名称 -f ：force 强制的意思，如果目标文件已经存在，不会询问而直接覆盖；-i ：若目标文件 (destination) 已经存在时，就会询问是否覆盖！-u ：若目标文件已经存在，且 source 比较新，才会升级 (update) 查看文件内容 cat 由第一行开始显示文件内容tac 从最后一行开始显示，可以看出 tac 是 cat 的倒著写！nl 显示的时候，顺道输出行号！more 一页一页的显示文件内容less 与 more 类似，但是比 more 更好的是，他可以往前翻页！head 只看头几行tail 只看尾巴几行 useradd 选项 用户名选项：-c comment 指定一段注释性描述。-d 目录 指定用户主目录，如果此目录不存在，则同时使用-m选项，可以创建主目录。-g 用户组 指定用户所属的用户组。-G 用户组，用户组 指定用户所属的附加组。-s Shell文件 指定用户的登录Shell。-u 用户号 指定用户的用户号，如果同时有-o选项，则可以重复使用其他用户的标识号。 eg: useradd -d /usr/seasonin -m -g root seasonin创建seasonin用户，用户主目录为/usr/seasonin，属于root组 userdel -r 用户名-r 练用户主目录一起删除 usermod 选项 用户名选项 -c, -d, -m, -g, -G, -s, -u passwd 选项 用户名-l 锁定用户-u 解锁用户-d 使账号无口令（密码）登录-f 强迫用户下次登录修改口令 Linux磁盘管理df 选项 目录或文件名检查文件系统的磁盘空间占用情况。可以利用该命令来获取硬盘被占用了多少空间，目前还剩下多少空间等信息 选项：-a ：列出所有的文件系统，包括系统特有的 /proc 等文件系统；-k ：以 KBytes 的容量显示各文件系统；-m ：以 MBytes 的容量显示各文件系统；-h ：以人们较易阅读的 GBytes, MBytes, KBytes 等格式自行显示；-H ：以 M=1000K 取代 M=1024K 的进位方式；-T ：显示文件系统类型, 连同该 partition 的 filesystem 名称 (例如 ext3) 也列出；-i ：不用硬盘容量，而以 inode 的数量来显示 du 选项 目录或文件名对文件和目录磁盘使用的空间的查看选项：-a ：列出所有的文件与目录容量，因为默认仅统计目录底下的文件量而已。-h ：以人们较易读的容量格式 (G/M) 显示；-s ：列出总量而已，而不列出每个各别的目录占用容量；-S ：不包括子目录下的总计，与 -s 有点差别。-k ：以 KBytes 列出容量显示；-m ：以 MBytes 列出容量显示； fdisk [-l] 装置名称磁盘分区表操作工具-l ：输出后面接的装置所有的分区内容 mkfs [-t 文件系统格式] 装置文件名磁盘格式化-t ：可以接文件系统格式，例如 ext3, ext2, vfat 等 fsck [-t 文件系统] [-ACay] 装置名称磁盘检验选项：-t : 给定档案系统的型式，若在 /etc/fstab 中已有定义或 kernel 本身已支援的则不需加上此参数-s : 依序一个一个地执行 fsck 的指令来检查-A : 对/etc/fstab 中所有列出来的 分区（partition）做检查-C : 显示完整的检查进度-d : 打印出 e2fsck 的 debug 结果-p : 同时有 -A 条件时，同时有多个 fsck 的检查一起执行-R : 同时有 -A 条件时，省略 / 不检查-V : 详细显示模式-a : 如果检查有错则自动修复-r : 如果检查有错则由使用者回答是否修复-y : 选项指定检测每个文件是自动输入yes，在不确定那些是不正常的时候，可以执行 # fsck -y 全部检查修复。 mount [-t 文件系统] [-L Label名] [-o 额外选项] [-n] 装置文件名 挂载点磁盘挂载 umount [-fn] 装置文件名或挂载点磁盘卸载选项：-f ：强制卸除！可用在类似网络文件系统 (NFS) 无法读取到的情况下；-n ：不升级 /etc/mtab 情况下卸除。 Linux yum命令yum [options] [command] [package …]options：可选，选项包括-h（帮助），-y（当安装过程提示选择全部为”yes”），-q（不显示安装的过程）等等。command：要进行的操作。package操作的对象。 yum常用命令1.列出所有可更新的软件清单命令：yum check-update2.更新所有软件命令：yum update3.仅安装指定的软件命令：yum install &lt;package_name&gt;4.仅更新指定的软件命令：yum update &lt;package_name&gt;5.列出所有可安裝的软件清单命令：yum list6.删除软件包命令：yum remove &lt;package_name&gt;7.查找软件包 命令：yum search 8.清除缓存命令:yum clean packages: 清除缓存目录下的软件包yum clean headers: 清除缓存目录下的 headersyum clean oldheaders: 清除缓存目录下旧的 headersyum clean, yum clean all (= yum clean packages; yum clean oldheaders) :清除缓存目录下的软件包及旧的headers]]></content>
      <categories>
        <category>学习</category>
        <category>Linux 文件与目录管理</category>
      </categories>
      <tags>
        <tag>Linux</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[learnNode3]]></title>
    <url>%2FmarkdownBlog.github.io%2F2019%2F03%2F18%2FlearnNode3%2F</url>
    <content type="text"><![CDATA[套接字之间传送的数字称为流，buffer对象在流中传送二进制数据，通过Unicode编码方式传送一个字符串。数据最终包装成数据包传送。套接字通过FIN数据包表明本次传输完成。本次创建一个TCP服务端，监听客户端的数据接收和客户端连接是否关闭。 1234567891011121314var net = require(&apos;net&apos;);var server = net.createServer(function(conn)&#123; console.log(&apos;connected&apos;); conn.on(&apos;data&apos;,function(data)&#123; console.log(data + &apos; from &apos; + conn.remoteAddress + &apos; &apos; + conn.remotePort); conn.write(&apos;Repeating: &apos;+data); &#125;); conn.on(&apos;close&apos;,function()&#123; console.log(&apos;Client closed connection&apos;); &#125;);&#125;).listen(8124);console.log(&apos;listening on port 8124&apos;); 创建TCP客户端，在套接字接口调用setEncoding方法改变接收数据的编码处理方式，转换为UTF8格式，监听数据接收和服务器连接关闭事件。 12345678910111213141516171819202122232425var net = require(&apos;net&apos;);var client = new net.Socket();client.setEncoding(&apos;utf8&apos;);client.connect(&apos;8124&apos;,&apos;localhost&apos;,function()&#123; console.log(&apos;connected to server&apos;); client.write(&apos;Who needs a browser to communicate?&apos;);&#125;);process.stdin.resume();//从终端（命令行）获取数据process.stdin.on(&apos;data&apos;,function(data)&#123; client.write(data);&#125;);client.on(&apos;data&apos;,function(data)&#123; console.log(data);&#125;);client.on(&apos;close&apos;,function()&#123; console.log(&apos;connection is closed&apos;);&#125;); UDP模块的标识符是dgram require(‘dgram’); UDP模块链接 UDP套接字只接受buffer对象，数据包装在buffer对象里面，调用buffer对象的toString方法将缓冲区的数据转换为一个字符串。下面为UDP客户端 12345678910111213var dgram = require(&apos;dgram&apos;);var client = dgram.createSocket(&apos;udp4&apos;);//创建UDP套接字参数udp4或udp6process.stdin.on(&apos;data&apos;,function(data)&#123; console.log(data.toString(&apos;utf8&apos;)); client.send(data,0,data.length,8124,&quot;localhost&quot;,function(err,bytes)&#123; if(err) console.log(&apos;error&apos;+err); else console.log(&apos;successful&apos;); &#125;);&#125;); UDP服务器端 12345678var dgram = require(&apos;dgram&apos;);var server = dgram.createSocket(&quot;udp4&quot;);server.on(&quot;message&quot;,function(msg,rinfo)&#123; console.log(&quot;message: &quot;+msg+&quot; from &quot; + rinfo.address+&quot;:&quot;+rinfo.port);&#125;);server.bind(8124); 无论UDP客户端还是服务端，不用使用close方法关闭套接字，因为没有维护一个持续连接 pine可将一个可读流和一个可写流连接起来12process.stdin.resume();process.stdin.pipe(process.stdout); readline1234567891011121314151617181920212223242526272829303132var readline = require(&apos;readline&apos;);var interface = readline.createInterface(process.stdin,process.stdout,null);interface.question(&quot;&gt;&gt;What is the meaning of meaning of life?&quot;,function(answer)&#123; console.log(&quot;About the meaning of life, you said &quot;+answer); interface.setPrompt(&quot;&gt;&gt;&quot;); interface.prompt();&#125;);function closeInterface()&#123; console.log(&apos;Leaving interface...&apos;); process.exit();&#125;interface.on(&apos;line&apos;,function(cmd)&#123; //input流接收到行尾输入（，或）\n，就会发出该事件 if(cmd.trim()==&apos;.leave&apos;) &#123; closeInterface(); return; &#125; else &#123; console.log(&quot;repeating command: &quot;+cmd); &#125; interface.setPrompt(&quot;&gt;&gt;&quot;); //rl.setPrompt()方法设置将在output每次rl.prompt()调用时写入的提示 interface.prompt(); //rl.prompt()方法将readline.Interface配置的实例 写入prompt新行，output以便为用户提供提供输入的新位置&#125;);interface.on(&apos;close&apos;,function()&#123; closeInterface();&#125;);]]></content>
      <categories>
        <category>学习</category>
        <category>node.js TCP服务器</category>
      </categories>
      <tags>
        <tag>node.js</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[useGit]]></title>
    <url>%2FmarkdownBlog.github.io%2F2019%2F03%2F10%2FuseGit%2F</url>
    <content type="text"><![CDATA[git常用命令 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879mkdir &lt;file&gt; 创建文件夹cd &lt;file&gt; 跳到具体文件夹pwd 显示当前路径git init 初始化git仓库git add &lt;filename&gt; 提交文件到仓库git add . 提交本地所有文件到仓库git commit -m&quot;describe&quot; 添加说明git status 仓库当前的状态git diff 查看修改的内容git log 查看历史记录，可查看版本号git log --pretty=oneline 查看一行记录git reflog 查看历史命令git reset --hard HEAD^ 返回到上一版本HEAD为当前版本，HEAD^为上一版本，同样HEAD^^为上上版本git reset --hard 版本号 返回到某一具体版本git checkout --&lt;filename&gt; 丢弃工作区的内容，即add提交的内容git reset HEAD &lt;filename&gt; 丢弃暂存区，回到工作区，即丢弃commit的内容git rm file 从版本库中删除文件rm file 删除文件git checkout --file 从版本库的文件替换工作区的文件ssh-keygen -t rsa -C &quot;email&quot; 创建SSH KEYgit remote add origin 仓库地址 关联远程库，库名origin可设其它git push -u origin master 第一次向远程库origin推送master分支的所有内容 git push origin master 向远程库origin推送master分支的最新内容git clone 仓库地址 克隆远程仓库，库名默认origingit checkout -b dev 创建并切换到dev分支git branch dev 创建dev分支git checkout dev 切换到dev分支git branch 查看当前分支git merge dev 把dev分支合并到当前分支下git branch -d dev 删除dev分支git log --graph 查看分支合并图git log --graph --pretty=oneline --abbrev-commit 查看简洁（一行）的分支合并图git merge --no-ff -m&quot;描述&quot; dev 采用no-ff普通模式的方式合并dev分支，会创建一个新的commit，加上-m描述git merge dev 默认采用fast -forward模式合并，会丢失分支信息合并分支步骤：1.合并无冲突，删除分支2.合并有冲突，手动修改冲突内容，提交内容，删除分支git stash 储藏未完成的工作，即储存工作区的内容，可恢复后台继续工作git stash list 查看工作现场git stash pop 恢复工作现场并删除stash内容git remote 查看远程库信息git remote -v 查看远程库详细信息git push origin dev 推送dev分支的内容到远程库推送失败处理步骤：git pull 抓取远程库的最新提交的内容，并手动解决冲突git checkout -b branch-name origin/branch-name 在本地创建和远程分支的关联git rebase 将提交到某一分支的所有内容修改并移到另一条分支上git tag &lt;tagname&gt; commiID 在最新提交的commit上打上标签，即默认commitID为HEAD，否则对应id打标签git tag -a &lt;tagname&gt; -m&quot;描述&quot; commitID 指定标签来添加描述git tag 查看所有标签git show &lt;tagname&gt; 查看标签信息git tag -d tagname 删除标签git push origin tagname 把本地标签推送到远程库git push origin --tags 一次推送全部本地标签到远程库git push origin irefs/tags/&lt;tagname&gt; 删除远程标签git remote rm origin 删除与远程库origin的联系根目录下创建.gitignore文件，填写文件名，该文件会被忽略]]></content>
      <categories>
        <category>学习</category>
        <category>命令</category>
      </categories>
      <tags>
        <tag>git</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[第一次]]></title>
    <url>%2FmarkdownBlog.github.io%2F2019%2F03%2F10%2FfirstTime%2F</url>
    <content type="text"><![CDATA[本人的第一个博客开通啦！我是谁？我从哪里来？又到那里去？这是一个有深意的问题。本人热爱学习，正在前端与后台领域奋斗 以下为初次练习Markdown 六级标题段落末尾两个以上空格加上回车 列表1 列表2 列表项 列表项 vue导航 斜体字加粗字删除线下划线 &lt;html&gt;一行代码嵌入区&lt;/html&gt; 123456&lt;html&gt;&lt;head&gt;标题&lt;/head&gt;&lt;body&gt; &lt;div&gt;&lt;p&gt;body主体&lt;/p&gt;&lt;/div&gt;&lt;/body&gt;&lt;/html&gt; 引用内容 分行]]></content>
      <categories>
        <category>我们聊聊</category>
      </categories>
      <tags>
        <tag>介绍</tag>
      </tags>
  </entry>
</search>
