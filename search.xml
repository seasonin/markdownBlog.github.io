<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title><![CDATA[seo]]></title>
    <url>%2FmarkdownBlog.github.io%2F2019%2F09%2F16%2Fseo%2F</url>
    <content type="text"><![CDATA[浅谈SEO 网站结构层次简单，一般中小型网站目录结构不要超过三级 网站首页链接适量，适量的桥可让“蜘蛛”继续往下爬到内页，尽量让“蜘蛛”跳转3次就可到达任何一个内页。但网站连接过多也不好，会影响用户体验 导航优化。导航采用文字，也可搭配图片导航，&lt;img&gt;标签必须添加alt和title属性。每一个页面添加面包屑 页面头部：logo及主导航，以及用户的信息。页面主体：左边正文，包括面包屑导航及正文；右边放热门文章及相关文章，好处：留住访客，让访客多停留，对“蜘蛛”而言，这些文章属于相关链接，增强了页面相关性，也能增强页面的权重。页面底部：版权信息和友情链接。 重要的内容放在最前 控制页面大小，减少http请求，提高网站加载速度 title标题，强调重点，关键词放在最前面，尽量做到每一个页面的title不设置相同的内容 meta keywords 标签，列出几个页面的重要关键词 description 标签，高度概括页面内容，切勿过于冗余 a 标签，加title属性以说明；img标签使用alt属性加以说明；表格使用caption表格标题Yang Xin Ming 作品导航 语法化书写HTML代码，h1-h6用于标题类,nav标签设置主导航，列表使用ul或ol，重要文字用strong 重要内容应放在HTML里不要使用js输出，因为蜘蛛不会读取JS里面的内容 尽量少使用iframe框架，蜘蛛一般不读取其中的内容 谨慎使用 display：none ：对于不想显示的文字内容，应当设置z-index或缩进设置成足够大的负数偏离出浏览器之外。因为搜索引擎会过滤掉display:none其中的内容。 减少http请求数量，合并css和js，采用懒加载，css放在头部，js放在底部，使用外联的css和js 减少DOM操作 图标使用IconFont 压缩代码、图片]]></content>
      <tags>
        <tag>seo优化</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[reviewJs]]></title>
    <url>%2FmarkdownBlog.github.io%2F2019%2F08%2F04%2FreviewJs%2F</url>
    <content type="text"><![CDATA[Js输出 使用 window.alert() 写入警告框使用 document.write() 写入 HTML 输出使用 innerHTML 写入 HTML 元素使用 console.log() 写入浏览器控制台 1234document.getElementById("demo").innerHTML = 5 + 6;document.write(5 + 6);window.alert(5 + 6);console.log(5 + 6); js比较符 123456== 等于=== 等值等型!= 不相等!== 不等值或不等型typeof 返回变量的类型。 =&gt; typeof 2 typeof function () &#123;&#125; instanceof 返回 true，如果对象是对象类型的实例。 js运算 12345678var z = x ** 2 //算x得2次幂var z = Math.pow(x, 2)超大或超小的数值可以用科学计数法来写：实例var y = 123e5; // 12300000var z = 123e-5; // 0.00123 HTML事件 123456onchange HTML 元素已被改变onclick 用户点击了 HTML 元素onmouseover 用户把鼠标移动到 HTML 元素上onmouseout 用户把鼠标移开 HTML 元素onkeydown 用户按下键盘按键onload 浏览器已经完成页面加载 \ 转义字符 var x = &quot;中国是瓷器的故乡，因此 china 与\&quot;China（中国）\&quot;同名。&quot; JavaScript 字符串方法 检索字符串1234567891011121314indexOf()，从零计算位置计算，返回字符串中指定文本首次出现的索引var str = &quot;The full name of China is the People&apos;s Republic of China.&quot;;var pos = str.indexOf(&quot;China&quot;);lastIndexOf()，从零计算位置计算，返回字符串中指定文本最后出现的索引var str = &quot;The full name of China is the People&apos;s Republic of China.&quot;;var pos = str.lastIndexOf(&quot;China&quot;);如果未找到文本， indexOf() 和 lastIndexOf() 均返回 -1。两种方法都接受作为检索起始位置的第二个参数。pos = str.indexOf(&apos;china&apos;, 18)search() 返回字符串中指定文本第一次出现的位置；方法无法设置第二个开始位置参数；可设置更强大的搜索值（正则表达式）。str.search(&apos;china&apos;) 提取部分字符串slice(start, end)从开始到结尾截取字符串，不包括结尾符。如果省略第二个参数，则该方法将裁剪字符串的剩余部分： substring(start, end)类似slice()，不同之处在于 substring() 无法接受负的索引。 substr(start, length)类似于 slice()，不同之处在于第二个参数规定被提取部分的长度。123var str = &quot;Apple, Banana, Mango&quot;;var res = str.slice(7,13);var res = str.slice(-13,-7); // 从结尾开始计数 提取字符串字符charAt() 方法返回字符串中指定下标的字符charCodeAt() 方法返回字符串中指定索引的字符的 unicode 编码&quot;hello&quot;.charAt(1) //返回e 替换字符串内容replace() 方法用另一个值替换在字符串中指定的值,只替换首个匹配12345678str = &quot;Please visit Microsoft and Microsoft!&quot;;var n = str.replace(&quot;Microsoft&quot;, &quot;W3School&quot;);replace() 对大小写敏感，如需执行大小写不敏感的替换，请使用正则表达式 /ivar n = str.replace(/MICROSOFT/i, &quot;W3School&quot;);如需替换所有匹配，请使用正则表达式的 g 标志（用于全局搜索）var n = str.replace(/Microsoft/g, &quot;W3School&quot;); 转换为大写和小写toUpperCase() 把字符串转换为大写，toLowerCase() 把字符串转换为小写&quot;Hello World!&quot;.toUpperCase() concat() 连接两个或多个字符串123var text1 = &quot;Hello&quot;;var text2 = &quot;World&quot;;text3 = text1.concat(&quot; &quot;, text2, &quot;!&quot;); trim() 方法删除字符串两端的空白符&quot; Hello World! &quot;.trim() 把字符串转换为数组split() 将字符串转换为数组如果省略分隔符，被返回的数组将包含 index [0] 中的整个字符串。 如果分隔符是 “”，被返回的数组将是间隔单个字符的数组“Hello”.split(“”) // 分隔为字符1234var txt = &quot;a,b,c,d,e&quot;; // 字符串txt.split(&quot;,&quot;); // 用逗号分隔txt.split(&quot; &quot;); // 用空格分隔txt.split(&quot;|&quot;); // 用竖线分隔 数值 typeof运算符typeof “Bill” // 返回 “string”typeof 314 // 返回 “number”typeof 运算符把对象、数组或 null 返回 objecttypeof function myFunc(){} // 返回 “function” Infinity （或 -Infinity）是 JavaScript 在计算数时超出最大可能数范围时返回的值NaN - 非数值 对象无法进行对比： 对象无法比较var x = new Number(500);var y = new Number(500);// (x == y) 为 false toString() 以字符串返回数值valueOf() 以数值返回数值(100 + 23).valueOf(); // 从表达式 100 + 23 返回 123 Number() 返回数字，由其参数转换而来。Number(false); // 返回 0Number(new Date(“2019-04-15”)); // 返回 1506729600000 parseFloat() 解析其参数并返回浮点数。parseInt() 解析其参数并返回整数。 数组 Array.foreach() 遍历数组元素添加数组元素var fruits = [“Banana”, “Orange”, “Apple”, “Mango”];fruits.push(“Lemon”); // 向 fruits 添加一个新元素 (Lemon) pop() 方法从数组中删除最后一个元素fruits.pop(); // 从 fruits 删除最后一个元素（”Mango”） 把数组转换为字符串document.getElementById(“demo”).innerHTML = fruits.toString(); // Banana,Orange,Apple,Mango join() 方法也可将所有数组元素结合为一个字符串。它的行为类似 toString()，但是您还可以规定分隔符fruits.join(“ “); // Banana Orange Apple Mango 位移元素shift() 方法会删除首个数组元素，并把所有其他元素“位移”到更低的索引。fruits.shift(); // 从 fruits 删除第一个元素 “Banana” 拼接数组第一个参数（2）定义了应添加新元素的位置（拼接），第二个参数（0）定义应删除多少元素。fruits.splice(2, 2, “Lemon”, “Kiwi”); // [“Banana”, “Orange”, “Lemon”, “Kiwi”] concat() 方法通过合并（连接）现有数组来创建一个新数组fruits.concat([“Lemon”, “Kiwi”]) 裁剪数组slice() 方法用数组的某个片段切出新数组。从开始参数选取元素，直到结束参数（不包括）为止；如果结束参数被省略，则 slice() 会切出数组的剩余部分 sort() 方法以字母顺序对数组进行排序按照字符串顺序对值进行排序比较函数应该返回一个负，零或正值，这取决于参var points = [40, 100, 1, 5, 25, 10];points.sort(function(a, b){return a - b}); 以随机顺序排序数组points.sort(function(a, b){return 0.5 - Math.random()}); reverse() 方法反转数组中的元素fruits.sort(); // 对 fruits 中的元素进行排序，Apple Banana,,Mango,Orangefruits.reverse(); // 反转元素，Orange,Mango,Banana,Apple 对数组使用 Math.max()您可以使用 Math.max.apply 来查找数组中的最高值：Math.max.apply([1, 2, 3]) 等于 Math.max(1, 2, 3)Math.min.apply([1, 2, 3]) 等于 Math.min(1, 2, 3) 数组迭代方法Array.forEach()forEach() 方法为每个数组元素调用一次函数该函数接受 3 个参数：项目值项目索引数组本身 1234567var num = [1, 2, 3]var text = ''num.forEach(function(value) &#123; text+= value + '&lt;br&gt;';&#125;);console.log(text); // 1&lt;br&gt;2&lt;br&gt;3&lt;br&gt; Array.map()map() 方法通过对每个数组元素执行函数来创建新数组。map() 方法不会对没有值的数组元素执行函数。map() 方法不会更改原始数组 123456var numbers1 = [45, 4, 9, 16, 25];var numbers2 = numbers1.map(myFunction);function myFunction(value, index, array) &#123; return value * 2;&#125; Array.filter()filter() 方法创建一个包含通过测试的数组元素的新数组。123456var numbers = [45, 4, 9, 16, 25];var over18 = numbers.filter(myFunction);function myFunction(value, index, array) &#123; return value &gt; 18;&#125; Array.every()every() 方法检查所有数组值是否通过测试。 这个例子检查所有数组值是否大于 18123456var numbers = [45, 4, 9, 16, 25];var allOver18 = numbers.every(myFunction); // falsefunction myFunction(value, index, array) &#123; return value &gt; 18;&#125; Array.some()some() 方法检查某些数组值是否通过了测试。 这个例子检查某些数组值是否大于 18 123456var numbers = [45, 4, 9, 16, 25];var someOver18 = numbers.some(myFunction); // truefunction myFunction(value, index, array) &#123; return value &gt; 18; &#125; Array.find()find() 方法返回通过测试函数的第一个数组元素的值。 这个例子查找（返回）大于 18 的第一个元素的值 123456var numbers = [4, 9, 16, 25, 29];var first = numbers.find(myFunction); // 25function myFunction(value, index, array) &#123; return value &gt; 18;&#125; Array.findIndex()findIndex() 方法返回通过测试函数的第一个数组元素的索引 日期new Date()，返回日期创建日期，var d = new Date(2019, 12, 3, 6, 40, 50, 0)，按照年月日时分秒毫秒的顺序创建新的日期对象也可var d = new Date(“2018-3-20T12:00:00”)，以时、分和秒 (YYYY-MM-DDTHH:MM:SS)的形式创建日期 JavaScript Math 对象Math.PI // 返回 3.141592653589793Math.round(x) 的返回值是 x 四舍五入为最接近的整数Math.pow(x, y) 的返回值是 x 的 y 次幂Math.sqrt(x) 返回 x 的平方根Math.abs(x) 返回 x 的绝对（正）值Math.ceil(x) 的返回值是 x 上舍入最接近的整数, Math.ceil(6.4) // 7Math.floor(x) 的返回值是 x 下舍入最接近的整数Math.sin(x) 返回角 x（以弧度计）的正弦（介于 -1 与 1 之间的值） Math.sin(90 * Math.PI / 180); // 返回 1（90 度的正弦）Math.cos(x) 返回角 x（以弧度计）的余弦（介于 -1 与 1 之间的值）Math.min() 和 Math.max() 可用于查找参数列表中的最低或最高值 Math.min(0, 450, 35, 10, -8, -300, -78); // 返回 -300Math.random() 返回介于 0（包括） 与 1（不包括） 之间的随机数 返回介于 min（包括）和 max（不包括）之间的随机数123function getRndInteger(min, max) &#123; return Math.floor(Math.random() * (max - min) ) + min;&#125; switch(表达式) { case n: 代码块 break; case n: 代码块 break; default: 默认代码块} continue 语句（不论有无标签引用）只能用于跳过一个迭代。 break 语句，如果没有标签引用，只能用于跳出一个循环或一个 switch。 如果有标签引用，则 break 语句可用于跳出任意代码块： 12345678910111213var cars = ["BMW", "Volvo", "porsche", "Ford"];var text = "";list: &#123; text += cars[0] + "&lt;br&gt;"; text += cars[1] + "&lt;br&gt;"; break list; text += cars[2] + "&lt;br&gt;"; text += cars[3] + "&lt;br&gt;"; &#125;// text: BMW Volvo constructor 属性constructor 属性返回所有 JavaScript 变量的构造器函数“Bill”.constructor // 返回 “function String() { [native code] }”(3.14).constructor // 返回 “function Number() { [native code] }”false.constructor // 返回 “function Boolean() { [native code] }”[1,2,3,4].constructor // 返回 “function Array() { [native code] }”{name:’Bill’, age:62}.constructor // 返回” function Object() { [native code] }”new Date().constructor // 返回 “function Date() { [native code] }”function () {}.constructor // 返回 “function Function(){ [native code] }” 123// 判断 myArray是否为数组return myArray.constructor.toString().indexOf("Array") &gt; -1;return myArray.constructor === Array; 正则表达式/pattern（模式）/modifiers（修饰符）; search() 方法使用表达式来搜索匹配，然后返回匹配的位置。replace() 方法返回模式被替换处修改后的字符串。 正则表达式修饰符i 执行对大小写不敏感的匹配。g 执行全局匹配（查找所有匹配而非在找到第一个匹配后停止）。m 执行多行匹配。 test()通过模式来搜索字符串，然后根据结果返回 true 或 false。/\d/g.test(‘sadfdsa123456’) //true exec() 它通过指定的模式（pattern）搜索字符串，并返回已找到的文本/e/.exec(“The best things in life are free!”);console.log(/(yxm)/.exec(‘a student named yxm’)); // [“yxm”, “yxm”, index: 16, input: “a student named yxm”, groups: undefined] match() 方法可在字符串内检索指定的值，或找到一个或多个正则表达式的匹配。该方法类似 indexOf() 和 lastIndexOf()，但是它返回指定的值，而不是字符串的位置。 使用prototype属性向对象构造器添加新属性1234567function Person(first, last, age, eyecolor) &#123; this.firstName = first; this.lastName = last; this.age = age; this.eyeColor = eyecolor;&#125;Person.prototype.nationality = "English"; arguments 对象JavaScript 函数有一个名为 arguments 对象的内置对象。arguments 对象包含函数调用时使用的参数数组。这样，您就可以简单地使用函数来查找（例如）数字列表中的最高值：实例1234567891011x = findMax(1, 123, 500, 115, 44, 88);function findMax() &#123; var i; var max = -Infinity; for (i = 0; i &lt; arguments.length; i++) &#123; if (arguments[i] &gt; max) &#123; max = arguments[i]; &#125; &#125; return max;&#125; 只调用函数，不被调用的情况下自动执行arguments.length // 返回参数数目123(function () &#123; var x = 'hello';&#125;)(); js call()方法通过call，可以使用另一对象apply与call相似，apply接受数组中的参数1234567891011121314var person1 = &#123; fistName: '杨', lastName: '过'&#125;var person = &#123; fullName: function(city, country) &#123; return this.fistName + this.lastName + city + country; &#125;&#125;console.log(person.fullName.call(person1, 'guangzhou', 'china')); //杨过guangzhouchinaconsole.log(person.fullName.apply(person1, ['guangzhou', 'china'])); //杨过guangzhou, chinaMath.max.apply(null, [1,2,3]); // 遍历数组的最大值，返回3 DOM修改属性、样式document.getElementById(id).attribute = new value修改HTML属性的值document.getElementById(‘myImage’).src = ‘car.jpg’ document.getElementById(id).style.property = new style修改元素样式document.getElementById(“p2”).style.color = “blue”; 如果您需要查找匹配指定 CSS 选择器（id、类名、类型、属性、属性值等等）的所有 HTML 元素，请使用 querySelectorAll() 方法。var x = document.querySelectorAll(“p.intro”); 如使用 getElementsByClassName() 方法，某些浏览器会返回 NodeList 对象而不是 HTMLCollection。所有浏览器都会为 childNodes 属性返回 NodeList 对象。大多数浏览器会为 querySelectorAll() 方法返回 NodeList 对象。NodeList 中的元素可通过索引号进行访问。y = myNodeList[1]; DOM事件onclickonload, onunload，用户进入或离开页面后触发，用于检测访问者的浏览器类型和浏览器版本，然后基于该信息加载网页的恰当版本。onchangeonmouseover, onmouseout，鼠标移至 HTML 元素上或移出时触发鼠标按钮被点击时，onmousedown 事件被触发；然后当鼠标按钮被释放时，onmouseup 事件被触发；最后，当鼠标点击完成后，onclick 事件被触发onfocus，获得焦点时触发 element.addEventListener(event, function, useCapture)，第三个参数是布尔值，指定使用事件冒泡还是事件捕获默认值是 false，将使用冒泡传播（由内向外处理时间），如果该值设置为 true，则事件使用捕获传播（由外向内处理事件）。element.addEventListener(event, function)123window.addEventListener("resize", function()&#123; document.getElementById("demo").innerHTML = window.innerWidth;&#125;); 节点导航 所有子节点（包括包括文本节点、注释节点即回车、换行、空格、文本等等）parentNodechildrenNodes[nodenumber]firstChildlastChildnextSiblingpreviousSibling children 返回元素子节点（元素节点）firstElementChild 返回第一个子节点（元素节点）lastElementChild 返回最后一个子节点（元素节点）parentElement 父节点（元素节点）nextElementSibling 返回元素的上一个兄弟元素节点（不包括文本节点、注释节点）previousElementSibling 返回元素的下一个兄弟元素节点（不包括文本节点、注释节点） 传递参数当传递参数值时，请以参数形式使用调用指定函数的“匿名函数”：element.addEventListener(“click”, function(){ myFunction(p1, p2); }); element.removeEventListener(“mousemove”, myFunction); HTML元素节点createElementcreateTextNodeappendChildinsertBeforeremoveChild1234567891011121314151617&lt;div id="div1"&gt;&lt;p id="p1"&gt;这是一个段落。&lt;/p&gt;&lt;p id="p2"&gt;这是另一个段落。&lt;/p&gt;&lt;/div&gt;&lt;script&gt;var para = document.createElement("p");var node = document.createTextNode("这是新文本。");para.appendChild(node);var element = document.getElementById("div1");element.appendChild(para);var p1 = document.getElementById('p1')element.insertBefore(para, p1);element.removeChild(document.getElementById('p2'));element.replaceChild(para, p1);&lt;/script&gt; window窗口浏览器窗口（浏览器视口）不包括工具栏和滚动条。window.innerHeight - 浏览器窗口的内高度（以像素计）window.innerWidth - 浏览器窗口的内宽度（以像素计）window.open() - 打开新窗口window.close() - 关闭当前窗口window.moveTo() -移动当前窗口window.resizeTo() -重新调整当前窗口 window locationwindow.location.href 当前页面的 href (URL)window.location.hostname web 主机的域名window.location.pathname 当前页面的路径或文件名window.location.protocol 使用的 web 协议（http: 或 https:）window.location.assign() 加载新文档 window.location.assign(“https://www.baidu.com&quot;)window.location.search 请求的参数window.location.hash 设置或获取 href 属性中在井号“#”后面的分段。 window History对象window.history.back() 加载历史列表中前一个 URLwindow.history.forward() 加载历史列表中下一个 URL history.go()：接受一个整数作为参数，以当前网址为基准，移动到参数指定的网址。如果参数超过实际存在的网址范围，该方法无效果；如果不指定参数，默认参数为0，相当于刷新当前页面。history.go(0)相当于刷新当前页面。history.go(1)相当于history.forward()，返回下一页history.go(-1)相当于history.back()，返回上一页 Navigator对象 txt = "浏览器代号: " + navigator.appCodeName + ""; txt+= "浏览器名称: " + navigator.appName + ""; txt+= "浏览器版本: " + navigator.appVersion + ""; txt+= "启用Cookies: " + navigator.cookieEnabled + ""; txt+= "硬件平台: " + navigator.platform + ""; txt+= "用户代理: " + navigator.userAgent + ""; txt+= "用户代理语言: " + navigator.systemLanguage + ""; document.getElementById("example").innerHTML=txt; 弹窗确认框 window.confirm(“sometext”);var r = confirm(“请按按钮”);if (r == true) { x = “您按了确认！”;} else { x = “您按了取消！”;} 计时事件setInterval(“javascript function”,milliseconds) - 间隔指定的毫秒数不停地执行指定的代码。clearInterval(intervalVariable)setTimeout(“javascript function”,milliseconds) - 在指定的毫秒数后执行指定代码。clearTimeout(timeoutVariable) cookie1.创建cookiedocument.cookie = “username=Bill Gates; expires=Sun, 31 Dec 2017 12:00:00 UTC; path=/“;2.删除cookiedocument.cookie = “username=; expires=Thu, 01 Jan 1970 00:00:00 UTC; path=/;”;]]></content>
      <tags>
        <tag>reviewJs</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[wrongSummery]]></title>
    <url>%2FmarkdownBlog.github.io%2F2019%2F05%2F11%2FwrongSummery%2F</url>
    <content type="text"><![CDATA[在公司上班的这段时间，我遇到了不少问题，也总结了许多 span标签跟在a标签后，如果设置a的width为100%，会引起span错位 span标签内若无内容，设置width无效，需加 display: block; 才生效 设置button居中，加 display: block; 和 margin: 0 auto，即设置button为block块 可设置width和padding来间接设置左右边距 bootStrap的container容器可能会影响div块的长度 几张块（如div、img）层叠在一起时可能会导致内层的元素（如button）无法正常使用，需设置好嵌套关系和z-index来解决，z-index设置对比层的同层关系 避免直接命名class为container等框架频繁词，应加上s-等前缀，避免样式冲突等问题 top、left可设置距离外元素的边距。结合translate: transform(x,y)，x、y指本元素左上角距离偏移量。 遵循样式尽量简洁的原则，避免造成样式混乱 a标签的width尽量大，如与其父级的div块同宽，方便用户点击 bootstrap container里面的row会超出左右-15px，可设置margin-left:0和margin-top:0，是row与container同宽 ::before 和 ::after 属性：content，在css渲染中向元素逻辑上的头部或尾部添加内容。这些添加不会出现在DOM中，不会改变文档内容，不可复制，仅仅是在css渲染层加入。 content的值:string；attr()调用当前元素的属性，比如将图片alt提示文字或者链接的href地址显示出来；url()，引用媒体文件；counter() 详细请见：https://www.cnblogs.com/starof/p/4459991.html 设置::before和::after伪类做背景叠加时，可设置z-index，使得伪类元素置上，底部之下，当底部有阴影渲染是不会污染到伪类元素]]></content>
      <categories>
        <category>学习</category>
        <category>总结</category>
      </categories>
      <tags>
        <tag>summery</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Vue Summarize Part 1]]></title>
    <url>%2FmarkdownBlog.github.io%2F2019%2F03%2F21%2FlearnVue%2F</url>
    <content type="text"><![CDATA[v-html:输出html内容将在div块内插入html内容1234&lt;div v-html=&quot;template&quot;&gt;&lt;/div&gt;data:&#123; template:&apos;&lt;div&gt;hello template&lt;/div&gt;&apos;&#125; 标签内可绑定属性值，js运算，三目运算，过滤器12345678910111213141516171819202122232425262728293031323334353637383940414243444546&#123;&#123;&#125;&#125;标签&lt;div id=&quot;app&quot;&gt;&#123;&#123; number / 10 &#125;&#125;&#123;&#123; isOK ? &apos;Y&apos; : &apos;N&apos; &#125;&#125;&#123;&#123; text.split(&apos;,&apos;) &#125;&#125;&#123;&#123; time | formateTime &#125;&#125;&lt;/div&gt;&lt;script&gt;var padDate = value =&gt; &#123; return value &lt; 10 ? &apos;0&apos; + value : value;&#125;var app = new Vue(&#123; el: &apos;app&apos;, data: &#123; number: 100, isOK: false, text: &apos;123,456&apos; &#125;, filters: &#123; formatTime: function (value) &#123; //value即为需要过滤的数据 var date = new Date(value) var year = date.getFullYear() var month = padDate(date.getMonth() + 1) var day = padDate(date.getDate()) var hours = padDate(date.getHours()) var minutes = padDate(date.getMinutes()) var seconds = padDate(date.getSeconds()) return year + &apos;-&apos; + month + &apos;-&apos; + day + &apos; &apos; + hours + &apos;:&apos; + minutes + &apos;:&apos; + seconds &#125; &#125;, mounted: function () &#123; // 挂载el后执行 var _this = this this.timer = setInterval(function () &#123; _this.time = new Date() // 修改数据Date &#125;, 1000) &#125;, beforeDestroy () &#123; // 实例销毁之前调用 if (this.timer) &#123; clearInterval(this.timer) &#125; &#125;&#125;)&lt;/script&gt; v-pre:12显示&#123;&#123;&#125;&#125;标签&lt;span v-pre&gt;&#123;&#123;这里的内容不会被编译&#125;&#125;&lt;/span&gt; v-bind:绑定属性，语法糖 :12345678910111213141516171819202122232425262728293031323334&lt;a v-bind:href=&quot;url&quot;&gt;百度&lt;/a&gt;data:&#123; url: &apos;https://www.baidu.com&apos;&#125;绑定class，对象语法和数组语法&lt;div class=&quot;static&quot; v-bind:class=&quot;[&#123; active: isActive, &apos;text-danger&apos;: hasError &#125;, activeClass, errorClass]&quot;&gt;&lt;/div&gt;data: &#123; isActive: true, hasError: false, activeClass: &apos;active&apos;, errorClass: &apos;text-danger&apos;&#125;绑定内联样式&lt;p :style=&quot;[fontStyles, backgroundStyles]&quot;&gt;字体为黄色，大小30px，背景灰色&lt;/p&gt;&lt;script&gt; let fontStyles = &#123; color: &apos;yellow&apos;, fontSize: &apos;30px&apos; &#125; let backgroundStyles = &#123; background: &apos;gray&apos; &#125; data: &#123; fontStyles, backgroundStyles &#125;&lt;/script&gt; v-on:绑定事件，语法糖 @123456&lt;button @click=&quot;add&quot;&gt;加一&lt;/button&gt;methods:&#123; add : function()&#123; this.count++; &#125;&#125; v-model:轻松实现表单输入和应用状态之间的双向绑定12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879808182修饰符v-model.number，仅接受数字输入.trim，自动过滤首尾空白符；.lazy，change时更新内容&lt;div id=&quot;app-6&quot;&gt; &lt;p&gt;&#123;&#123; message &#125;&#125;&lt;/p&gt; &lt;input v-model=&quot;message&quot;&gt;&lt;/div&gt;var app6 = new Vue(&#123; el: &apos;#app-6&apos;, data: &#123; message: &apos;Hello Vue!&apos; &#125;&#125;)多行文本&lt;p style=&quot;white-space: pre-line;&quot;&gt;&#123;&#123; message &#125;&#125;&lt;/p&gt;&lt;br&gt;&lt;textarea v-model=&quot;message&quot; placeholder=&quot;add multiple lines&quot;&gt;&lt;/textarea&gt;复选框&lt;input type=&quot;checkbox&quot; id=&quot;checkbox&quot; v-model=&quot;checked&quot;&gt;&lt;label for=&quot;checkbox&quot;&gt;&#123;&#123; checked &#125;&#125;&lt;/label&gt;多个复选框&lt;div id=&apos;example-3&apos;&gt; &lt;input type=&quot;checkbox&quot; id=&quot;jack&quot; value=&quot;Jack&quot; v-model=&quot;checkedNames&quot;&gt; &lt;label for=&quot;jack&quot;&gt;Jack&lt;/label&gt; &lt;input type=&quot;checkbox&quot; id=&quot;john&quot; value=&quot;John&quot; v-model=&quot;checkedNames&quot;&gt; &lt;label for=&quot;john&quot;&gt;John&lt;/label&gt; &lt;input type=&quot;checkbox&quot; id=&quot;mike&quot; value=&quot;Mike&quot; v-model=&quot;checkedNames&quot;&gt; &lt;label for=&quot;mike&quot;&gt;Mike&lt;/label&gt; &lt;br&gt; &lt;span&gt;Checked names: &#123;&#123; checkedNames &#125;&#125;&lt;/span&gt;&lt;/div&gt;new Vue(&#123; el: &apos;#example-3&apos;, data: &#123; checkedNames: [] &#125;&#125;)单个按钮&lt;div id=&quot;example-4&quot;&gt; &lt;input type=&quot;radio&quot; id=&quot;one&quot; value=&quot;One&quot; v-model=&quot;picked&quot;&gt; &lt;label for=&quot;one&quot;&gt;One&lt;/label&gt; &lt;br&gt; &lt;input type=&quot;radio&quot; id=&quot;two&quot; value=&quot;Two&quot; v-model=&quot;picked&quot;&gt; &lt;label for=&quot;two&quot;&gt;Two&lt;/label&gt; &lt;br&gt; &lt;span&gt;Picked: &#123;&#123; picked &#125;&#125;&lt;/span&gt;&lt;/div&gt;new Vue(&#123; el: &apos;#example-4&apos;, data: &#123; picked: &apos;&apos; &#125;&#125;)选择框&lt;div id=&quot;example-5&quot;&gt; &lt;select v-model=&quot;selected&quot;&gt; &lt;!--multiple属性，多选--&gt; &lt;option v-for=&quot;option in options&quot; v-bind:value=&quot;option.value&quot;&gt; &#123;&#123; option.text &#125;&#125; &lt;/option&gt; &lt;/select&gt; &lt;span&gt;Selected: &#123;&#123; selected &#125;&#125;&lt;/span&gt;&lt;/div&gt;new Vue(&#123; el: &apos;...&apos;, data: &#123; selected: &apos;A&apos;, options: [ &#123; text: &apos;One&apos;, value: &apos;A&apos; &#125;, &#123; text: &apos;Two&apos;, value: &apos;B&apos; &#125;, &#123; text: &apos;Three&apos;, value: &apos;C&apos; &#125; ] &#125;&#125;) 侦听器：watch123456789101112&lt;div&gt;&#123;&#123;msg&#125;&#125;&lt;/div&gt;watch: &#123; msg:function(newVal,oldVal) &#123; console.log(&apos;newVal is: &apos;+newVal); console.log(&apos;oldVal is: &apos;+oldVal); &#125;, another:function(newVal,oldVal) &#123; console.log(&apos;newVal is: &apos;+newVal); console.log(&apos;oldVal is: &apos;+oldVal); &#125; //仅监听一个变量&#125; 计算属性： computed区别watch，computed可以同时监听多个数据，数据联动区别methods，计算属性是基于它们的响应式依赖进行缓存的。只在相关响应式依赖发生改变时它们才会重新求值。methods多次执行，不设置缓存。1234567&lt;div&gt;&#123;&#123;msg1&#125;&#125;&lt;/div&gt;computed: &#123; msg1:function()&#123; return &apos;computed: &apos; + this.msg + &apos;,&apos; + this.another; //监听Vue实例内的两个变量msg和another变量 &#125;&#125; 条件渲染v-if,v-else-if,v-else,v-show123456789101112131415161718192021&lt;div v-if=&quot;count&gt;0&quot;&gt; 判断1：&#123;&#123;count&#125;&#125;&lt;/div&gt;&lt;div v-else-if=&quot;count&lt;=0&amp;&amp;count&gt;-5&quot;&gt; 判断2：&#123;&#123;count&#125;&#125;&lt;/div&gt;&lt;div v-else&gt; 判断3：&#123;&#123;count&#125;&#125;&lt;/div&gt;&lt;div v-show=&quot;bool&quot;&gt; show字段 &lt;/div&gt;&lt;script&gt;var app = new Vue(&#123; el:&apos;#app&apos;, data:&#123; count:0, show:true &#125;&#125;)&lt;/script&gt; 循环列表v-for，:class与样式(:style)绑定123456789101112131415161718&lt;div v-for=&quot;(item, index) in items&quot; :style=&quot;styleMsg&quot; :class=&quot;[&apos;one&apos;,&apos;two&apos;,&#123;&apos;active&apos;:item.age&gt;18&#125;]&quot;&gt; &#123;&#123;item.name&#125;&#125; - &#123;&#123; index &#125;&#125;&lt;/div&gt;styleMsg:&#123; color:&apos;red&apos;, fontSize:&apos;30px&apos;&#125;,items:[ &#123; name:&apos;lili&apos;, age:20 &#125;, &#123; name:&apos;huhu&apos;, age:18 &#125;] HTML 中的特性名是大小写不敏感的，所以浏览器会把所有大写字符解释为小写字符。当在 HTML 中使用大写字母时， DOM 中的模板需转换为小写字母。当 HTML 使用kebab-case (短横线分隔命名) 命名时， DOM 中的模板用 camelCase (驼峰命名法)。 vue-cli 全局安装 npm install -g @vue/cli 通过命令行创建一个项目vue create filePath fileNamecd fileNamenpm run serve 运行项目 或者通过图形界面创建一个项目vue ui 运行服务npm run serve 运行整个vue项目vue serve file.vue 运行单个vue文件 初始化项目依赖vue init template-name || webpack project-namecd project-namenpm install 安装项目所需的依赖 几种常用的调试方法 1.console.log()2.console.error()3.alert()4.debugger5.Vue插件6.Network，查看加载的项，查询http请求；调试页面交互，选择阻塞运行，online选项可选择相应的网速7.window.vue = this 代替debugger，console窗口输入window.vue.元素，window对象绑定8.var app = new vue({})，通过app.元素调试，vm实例]]></content>
      <categories>
        <category>学习</category>
        <category>Vue</category>
      </categories>
      <tags>
        <tag>Vue</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[learnLinux]]></title>
    <url>%2FmarkdownBlog.github.io%2F2019%2F03%2F20%2FlearnLinux%2F</url>
    <content type="text"><![CDATA[ls [-adl]：列出目录 -a ：全部的文件，连同隐藏档( 开头为 . 的文件) 一起列出来-d ：仅列出目录本身，而不是列出目录内的文件数据-l ：长数据串列出，包含文件的属性与权限等等数据 cd: 切换目录 cd filenamecd ~ 切换到/root目录cd.. 切换到上一级目录 pwd [-P]: 显示当前[确实完整的]目录 mkdir [-mp]: 创建一个新的目录 m 配置目录权限p 将目录(包含上一级目录)递归创建 rmdir [-p]: 删除一个空的目录 p连同上级目录一起删除 cp (source) (destination): 复制文件或目录 rm [-fir]: 移除文件或目录 -f ：就是 force 的意思，忽略不存在的文件，不会出现警告信息；-i ：互动模式，在删除前会询问使用者是否动作-r ：递归删除,危险的选项！ mv [-fiu] source destination: 移动文件与目录，或修改文件与目录的名称 -f ：force 强制的意思，如果目标文件已经存在，不会询问而直接覆盖；-i ：若目标文件 (destination) 已经存在时，就会询问是否覆盖！-u ：若目标文件已经存在，且 source 比较新，才会升级 (update) 查看文件内容 cat 由第一行开始显示文件内容tac 从最后一行开始显示，可以看出 tac 是 cat 的倒著写！nl 显示的时候，顺道输出行号！more 一页一页的显示文件内容less 与 more 类似，但是比 more 更好的是，他可以往前翻页！head 只看头几行tail 只看尾巴几行 useradd 选项 用户名选项：-c comment 指定一段注释性描述。-d 目录 指定用户主目录，如果此目录不存在，则同时使用-m选项，可以创建主目录。-g 用户组 指定用户所属的用户组。-G 用户组，用户组 指定用户所属的附加组。-s Shell文件 指定用户的登录Shell。-u 用户号 指定用户的用户号，如果同时有-o选项，则可以重复使用其他用户的标识号。 eg: useradd -d /usr/seasonin -m -g root seasonin创建seasonin用户，用户主目录为/usr/seasonin，属于root组 userdel -r 用户名-r 练用户主目录一起删除 usermod 选项 用户名选项 -c, -d, -m, -g, -G, -s, -u passwd 选项 用户名-l 锁定用户-u 解锁用户-d 使账号无口令（密码）登录-f 强迫用户下次登录修改口令 Linux磁盘管理df 选项 目录或文件名检查文件系统的磁盘空间占用情况。可以利用该命令来获取硬盘被占用了多少空间，目前还剩下多少空间等信息 选项：-a ：列出所有的文件系统，包括系统特有的 /proc 等文件系统；-k ：以 KBytes 的容量显示各文件系统；-m ：以 MBytes 的容量显示各文件系统；-h ：以人们较易阅读的 GBytes, MBytes, KBytes 等格式自行显示；-H ：以 M=1000K 取代 M=1024K 的进位方式；-T ：显示文件系统类型, 连同该 partition 的 filesystem 名称 (例如 ext3) 也列出；-i ：不用硬盘容量，而以 inode 的数量来显示 du 选项 目录或文件名对文件和目录磁盘使用的空间的查看选项：-a ：列出所有的文件与目录容量，因为默认仅统计目录底下的文件量而已。-h ：以人们较易读的容量格式 (G/M) 显示；-s ：列出总量而已，而不列出每个各别的目录占用容量；-S ：不包括子目录下的总计，与 -s 有点差别。-k ：以 KBytes 列出容量显示；-m ：以 MBytes 列出容量显示； fdisk [-l] 装置名称磁盘分区表操作工具-l ：输出后面接的装置所有的分区内容 mkfs [-t 文件系统格式] 装置文件名磁盘格式化-t ：可以接文件系统格式，例如 ext3, ext2, vfat 等 fsck [-t 文件系统] [-ACay] 装置名称磁盘检验选项：-t : 给定档案系统的型式，若在 /etc/fstab 中已有定义或 kernel 本身已支援的则不需加上此参数-s : 依序一个一个地执行 fsck 的指令来检查-A : 对/etc/fstab 中所有列出来的 分区（partition）做检查-C : 显示完整的检查进度-d : 打印出 e2fsck 的 debug 结果-p : 同时有 -A 条件时，同时有多个 fsck 的检查一起执行-R : 同时有 -A 条件时，省略 / 不检查-V : 详细显示模式-a : 如果检查有错则自动修复-r : 如果检查有错则由使用者回答是否修复-y : 选项指定检测每个文件是自动输入yes，在不确定那些是不正常的时候，可以执行 # fsck -y 全部检查修复。 mount [-t 文件系统] [-L Label名] [-o 额外选项] [-n] 装置文件名 挂载点磁盘挂载 umount [-fn] 装置文件名或挂载点磁盘卸载选项：-f ：强制卸除！可用在类似网络文件系统 (NFS) 无法读取到的情况下；-n ：不升级 /etc/mtab 情况下卸除。 Linux yum命令yum [options] [command] [package …]options：可选，选项包括-h（帮助），-y（当安装过程提示选择全部为”yes”），-q（不显示安装的过程）等等。command：要进行的操作。package操作的对象。 yum常用命令1.列出所有可更新的软件清单命令：yum check-update2.更新所有软件命令：yum update3.仅安装指定的软件命令：yum install &lt;package_name&gt;4.仅更新指定的软件命令：yum update &lt;package_name&gt;5.列出所有可安裝的软件清单命令：yum list6.删除软件包命令：yum remove &lt;package_name&gt;7.查找软件包 命令：yum search 8.清除缓存命令:yum clean packages: 清除缓存目录下的软件包yum clean headers: 清除缓存目录下的 headersyum clean oldheaders: 清除缓存目录下旧的 headersyum clean, yum clean all (= yum clean packages; yum clean oldheaders) :清除缓存目录下的软件包及旧的headers]]></content>
      <categories>
        <category>学习</category>
        <category>Linux 文件与目录管理</category>
      </categories>
      <tags>
        <tag>Linux</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[learnNode3]]></title>
    <url>%2FmarkdownBlog.github.io%2F2019%2F03%2F18%2FlearnNode3%2F</url>
    <content type="text"><![CDATA[套接字之间传送的数字称为流，buffer对象在流中传送二进制数据，通过Unicode编码方式传送一个字符串。数据最终包装成数据包传送。套接字通过FIN数据包表明本次传输完成。本次创建一个TCP服务端，监听客户端的数据接收和客户端连接是否关闭。 1234567891011121314var net = require(&apos;net&apos;);var server = net.createServer(function(conn)&#123; console.log(&apos;connected&apos;); conn.on(&apos;data&apos;,function(data)&#123; console.log(data + &apos; from &apos; + conn.remoteAddress + &apos; &apos; + conn.remotePort); conn.write(&apos;Repeating: &apos;+data); &#125;); conn.on(&apos;close&apos;,function()&#123; console.log(&apos;Client closed connection&apos;); &#125;);&#125;).listen(8124);console.log(&apos;listening on port 8124&apos;); 创建TCP客户端，在套接字接口调用setEncoding方法改变接收数据的编码处理方式，转换为UTF8格式，监听数据接收和服务器连接关闭事件。 12345678910111213141516171819202122232425var net = require(&apos;net&apos;);var client = new net.Socket();client.setEncoding(&apos;utf8&apos;);client.connect(&apos;8124&apos;,&apos;localhost&apos;,function()&#123; console.log(&apos;connected to server&apos;); client.write(&apos;Who needs a browser to communicate?&apos;);&#125;);process.stdin.resume();//从终端（命令行）获取数据process.stdin.on(&apos;data&apos;,function(data)&#123; client.write(data);&#125;);client.on(&apos;data&apos;,function(data)&#123; console.log(data);&#125;);client.on(&apos;close&apos;,function()&#123; console.log(&apos;connection is closed&apos;);&#125;); UDP模块的标识符是dgram require(‘dgram’); UDP模块链接 UDP套接字只接受buffer对象，数据包装在buffer对象里面，调用buffer对象的toString方法将缓冲区的数据转换为一个字符串。下面为UDP客户端 12345678910111213var dgram = require(&apos;dgram&apos;);var client = dgram.createSocket(&apos;udp4&apos;);//创建UDP套接字参数udp4或udp6process.stdin.on(&apos;data&apos;,function(data)&#123; console.log(data.toString(&apos;utf8&apos;)); client.send(data,0,data.length,8124,&quot;localhost&quot;,function(err,bytes)&#123; if(err) console.log(&apos;error&apos;+err); else console.log(&apos;successful&apos;); &#125;);&#125;); UDP服务器端 12345678var dgram = require(&apos;dgram&apos;);var server = dgram.createSocket(&quot;udp4&quot;);server.on(&quot;message&quot;,function(msg,rinfo)&#123; console.log(&quot;message: &quot;+msg+&quot; from &quot; + rinfo.address+&quot;:&quot;+rinfo.port);&#125;);server.bind(8124); 无论UDP客户端还是服务端，不用使用close方法关闭套接字，因为没有维护一个持续连接 pine可将一个可读流和一个可写流连接起来12process.stdin.resume();process.stdin.pipe(process.stdout); readline1234567891011121314151617181920212223242526272829303132var readline = require(&apos;readline&apos;);var interface = readline.createInterface(process.stdin,process.stdout,null);interface.question(&quot;&gt;&gt;What is the meaning of meaning of life?&quot;,function(answer)&#123; console.log(&quot;About the meaning of life, you said &quot;+answer); interface.setPrompt(&quot;&gt;&gt;&quot;); interface.prompt();&#125;);function closeInterface()&#123; console.log(&apos;Leaving interface...&apos;); process.exit();&#125;interface.on(&apos;line&apos;,function(cmd)&#123; //input流接收到行尾输入（，或）\n，就会发出该事件 if(cmd.trim()==&apos;.leave&apos;) &#123; closeInterface(); return; &#125; else &#123; console.log(&quot;repeating command: &quot;+cmd); &#125; interface.setPrompt(&quot;&gt;&gt;&quot;); //rl.setPrompt()方法设置将在output每次rl.prompt()调用时写入的提示 interface.prompt(); //rl.prompt()方法将readline.Interface配置的实例 写入prompt新行，output以便为用户提供提供输入的新位置&#125;);interface.on(&apos;close&apos;,function()&#123; closeInterface();&#125;);]]></content>
      <categories>
        <category>学习</category>
        <category>node.js TCP服务器</category>
      </categories>
      <tags>
        <tag>node.js</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[useGit]]></title>
    <url>%2FmarkdownBlog.github.io%2F2019%2F03%2F10%2FuseGit%2F</url>
    <content type="text"><![CDATA[git常用命令 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879mkdir &lt;file&gt; 创建文件夹cd &lt;file&gt; 跳到具体文件夹pwd 显示当前路径git init 初始化git仓库git add &lt;filename&gt; 提交文件到仓库git add . 提交本地所有文件到仓库git commit -m&quot;describe&quot; 添加说明git status 仓库当前的状态git diff 查看修改的内容git log 查看历史记录，可查看版本号git log --pretty=oneline 查看一行记录git reflog 查看历史命令git reset --hard HEAD^ 返回到上一版本HEAD为当前版本，HEAD^为上一版本，同样HEAD^^为上上版本git reset --hard 版本号 返回到某一具体版本git checkout --&lt;filename&gt; 丢弃工作区的内容，即add提交的内容git reset HEAD &lt;filename&gt; 丢弃暂存区，回到工作区，即丢弃commit的内容git rm file 从版本库中删除文件rm file 删除文件git checkout --file 从版本库的文件替换工作区的文件ssh-keygen -t rsa -C &quot;email&quot; 创建SSH KEYgit remote add origin 仓库地址 关联远程库，库名origin可设其它git push -u origin master 第一次向远程库origin推送master分支的所有内容 git push origin master 向远程库origin推送master分支的最新内容git clone 仓库地址 克隆远程仓库，库名默认origingit checkout -b dev 创建并切换到dev分支git branch dev 创建dev分支git checkout dev 切换到dev分支git branch 查看当前分支git merge dev 把dev分支合并到当前分支下git branch -d dev 删除dev分支git log --graph 查看分支合并图git log --graph --pretty=oneline --abbrev-commit 查看简洁（一行）的分支合并图git merge --no-ff -m&quot;描述&quot; dev 采用no-ff普通模式的方式合并dev分支，会创建一个新的commit，加上-m描述git merge dev 默认采用fast -forward模式合并，会丢失分支信息合并分支步骤：1.合并无冲突，删除分支2.合并有冲突，手动修改冲突内容，提交内容，删除分支git stash 储藏未完成的工作，即储存工作区的内容，可恢复后台继续工作git stash list 查看工作现场git stash pop 恢复工作现场并删除stash内容git remote 查看远程库信息git remote -v 查看远程库详细信息git push origin dev 推送dev分支的内容到远程库推送失败处理步骤：git pull 抓取远程库的最新提交的内容，并手动解决冲突git checkout -b branch-name origin/branch-name 在本地创建和远程分支的关联git rebase 将提交到某一分支的所有内容修改并移到另一条分支上git tag &lt;tagname&gt; commiID 在最新提交的commit上打上标签，即默认commitID为HEAD，否则对应id打标签git tag -a &lt;tagname&gt; -m&quot;描述&quot; commitID 指定标签来添加描述git tag 查看所有标签git show &lt;tagname&gt; 查看标签信息git tag -d tagname 删除标签git push origin tagname 把本地标签推送到远程库git push origin --tags 一次推送全部本地标签到远程库git push origin irefs/tags/&lt;tagname&gt; 删除远程标签git remote rm origin 删除与远程库origin的联系根目录下创建.gitignore文件，填写文件名，该文件会被忽略]]></content>
      <categories>
        <category>学习</category>
        <category>命令</category>
      </categories>
      <tags>
        <tag>git</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[第一次]]></title>
    <url>%2FmarkdownBlog.github.io%2F2019%2F03%2F10%2FfirstTime%2F</url>
    <content type="text"><![CDATA[本人的第一个博客开通啦！我是谁？我从哪里来？又到那里去？这是一个有深意的问题。本人热爱学习，正在前端与后台领域奋斗 以下为初次练习Markdown 六级标题段落末尾两个以上空格加上回车 列表1 列表2 列表项 列表项 vue导航 斜体字加粗字删除线下划线 &lt;html&gt;一行代码嵌入区&lt;/html&gt; 123456&lt;html&gt;&lt;head&gt;标题&lt;/head&gt;&lt;body&gt; &lt;div&gt;&lt;p&gt;body主体&lt;/p&gt;&lt;/div&gt;&lt;/body&gt;&lt;/html&gt; 引用内容 分行]]></content>
      <categories>
        <category>我们聊聊</category>
      </categories>
      <tags>
        <tag>介绍</tag>
      </tags>
  </entry>
</search>
