<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title><![CDATA[reviewJs]]></title>
    <url>%2FmarkdownBlog.github.io%2F2019%2F08%2F04%2FreviewJs%2F</url>
    <content type="text"><![CDATA[Js输出 使用 window.alert() 写入警告框使用 document.write() 写入 HTML 输出使用 innerHTML 写入 HTML 元素使用 console.log() 写入浏览器控制台 1234document.getElementById("demo").innerHTML = 5 + 6;document.write(5 + 6);window.alert(5 + 6);console.log(5 + 6); js比较符 123456== 等于=== 等值等型!= 不相等!== 不等值或不等型typeof 返回变量的类型。 =&gt; typeof 2 typeof function () &#123;&#125; instanceof 返回 true，如果对象是对象类型的实例。 js运算 12345678var z = x ** 2 //算x得2次幂var z = Math.pow(x, 2)超大或超小的数值可以用科学计数法来写：实例var y = 123e5; // 12300000var z = 123e-5; // 0.00123 HTML事件 123456onchange HTML 元素已被改变onclick 用户点击了 HTML 元素onmouseover 用户把鼠标移动到 HTML 元素上onmouseout 用户把鼠标移开 HTML 元素onkeydown 用户按下键盘按键onload 浏览器已经完成页面加载 \ 转义字符 var x = &quot;中国是瓷器的故乡，因此 china 与\&quot;China（中国）\&quot;同名。&quot; JavaScript 字符串方法 检索字符串1234567891011121314indexOf()，从零计算位置计算，返回字符串中指定文本首次出现的索引var str = &quot;The full name of China is the People&apos;s Republic of China.&quot;;var pos = str.indexOf(&quot;China&quot;);lastIndexOf()，从零计算位置计算，返回字符串中指定文本最后出现的索引var str = &quot;The full name of China is the People&apos;s Republic of China.&quot;;var pos = str.lastIndexOf(&quot;China&quot;);如果未找到文本， indexOf() 和 lastIndexOf() 均返回 -1。两种方法都接受作为检索起始位置的第二个参数。pos = str.indexOf(&apos;china&apos;, 18)search() 返回字符串中指定文本第一次出现的位置；方法无法设置第二个开始位置参数；可设置更强大的搜索值（正则表达式）。str.search(&apos;china&apos;) 提取部分字符串slice(start, end)从开始到结尾截取字符串，不包括结尾符。如果省略第二个参数，则该方法将裁剪字符串的剩余部分： substring(start, end)类似slice()，不同之处在于 substring() 无法接受负的索引。 substr(start, length)类似于 slice()，不同之处在于第二个参数规定被提取部分的长度。123var str = &quot;Apple, Banana, Mango&quot;;var res = str.slice(7,13);var res = str.slice(-13,-7); // 从结尾开始计数 提取字符串字符charAt() 方法返回字符串中指定下标的字符charCodeAt() 方法返回字符串中指定索引的字符的 unicode 编码&quot;hello&quot;.charAt(1) //返回e 替换字符串内容replace() 方法用另一个值替换在字符串中指定的值,只替换首个匹配12345678str = &quot;Please visit Microsoft and Microsoft!&quot;;var n = str.replace(&quot;Microsoft&quot;, &quot;W3School&quot;);replace() 对大小写敏感，如需执行大小写不敏感的替换，请使用正则表达式 /ivar n = str.replace(/MICROSOFT/i, &quot;W3School&quot;);如需替换所有匹配，请使用正则表达式的 g 标志（用于全局搜索）var n = str.replace(/Microsoft/g, &quot;W3School&quot;); 转换为大写和小写toUpperCase() 把字符串转换为大写，toLowerCase() 把字符串转换为小写&quot;Hello World!&quot;.toUpperCase() concat() 连接两个或多个字符串123var text1 = &quot;Hello&quot;;var text2 = &quot;World&quot;;text3 = text1.concat(&quot; &quot;, text2, &quot;!&quot;); trim() 方法删除字符串两端的空白符&quot; Hello World! &quot;.trim() 把字符串转换为数组split() 将字符串转换为数组如果省略分隔符，被返回的数组将包含 index [0] 中的整个字符串。 如果分隔符是 “”，被返回的数组将是间隔单个字符的数组“Hello”.split(“”) // 分隔为字符1234var txt = &quot;a,b,c,d,e&quot;; // 字符串txt.split(&quot;,&quot;); // 用逗号分隔txt.split(&quot; &quot;); // 用空格分隔txt.split(&quot;|&quot;); // 用竖线分隔]]></content>
      <tags>
        <tag>reviewJs</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[wrongSummery]]></title>
    <url>%2FmarkdownBlog.github.io%2F2019%2F05%2F11%2FwrongSummery%2F</url>
    <content type="text"><![CDATA[在公司上班的这段时间，我遇到了不少问题，也总结了许多 span标签跟在a标签后，如果设置a的width为100%，会引起span错位 span标签内若无内容，设置width无效，需加 display: block; 才生效 设置button居中，加 display: block; 和 margin: 0 auto，即设置button为block块 可设置width和padding来间接设置左右边距 bootStrap的container容器可能会影响div块的长度 几张块（如div、img）层叠在一起时可能会导致内层的元素（如button）无法正常使用，需设置好嵌套关系和z-index来解决，z-index设置对比层的同层关系 避免直接命名class为container等框架频繁词，应加上s-等前缀，避免样式冲突等问题 top、left可设置距离外元素的边距。结合translate: transform(x,y)，x、y指本元素左上角距离偏移量。 遵循样式尽量简洁的原则，避免造成样式混乱 a标签的width尽量大，如与其父级的div块同宽，方便用户点击 bootstrap container里面的row会超出左右-15px，可设置margin-left:0和margin-top:0，是row与container同宽 ::before 和 ::after 属性：content，在css渲染中向元素逻辑上的头部或尾部添加内容。这些添加不会出现在DOM中，不会改变文档内容，不可复制，仅仅是在css渲染层加入。 content的值:string；attr()调用当前元素的属性，比如将图片alt提示文字或者链接的href地址显示出来；url()，引用媒体文件；counter() 详细请见：https://www.cnblogs.com/starof/p/4459991.html 设置::before和::after伪类做背景叠加时，可设置z-index，使得伪类元素置上，底部之下，当底部有阴影渲染是不会污染到伪类元素]]></content>
      <categories>
        <category>学习</category>
        <category>总结</category>
      </categories>
      <tags>
        <tag>summery</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Vue Summarize Part 1]]></title>
    <url>%2FmarkdownBlog.github.io%2F2019%2F03%2F21%2FlearnVue%2F</url>
    <content type="text"><![CDATA[v-html:输出html内容将在div块内插入html内容1234&lt;div v-html=&quot;template&quot;&gt;&lt;/div&gt;data:&#123; template:&apos;&lt;div&gt;hello template&lt;/div&gt;&apos;&#125; 标签内可绑定属性值，js运算，三目运算，过滤器12345678910111213141516171819202122232425262728293031323334353637383940414243444546&#123;&#123;&#125;&#125;标签&lt;div id=&quot;app&quot;&gt;&#123;&#123; number / 10 &#125;&#125;&#123;&#123; isOK ? &apos;Y&apos; : &apos;N&apos; &#125;&#125;&#123;&#123; text.split(&apos;,&apos;) &#125;&#125;&#123;&#123; time | formateTime &#125;&#125;&lt;/div&gt;&lt;script&gt;var padDate = value =&gt; &#123; return value &lt; 10 ? &apos;0&apos; + value : value;&#125;var app = new Vue(&#123; el: &apos;app&apos;, data: &#123; number: 100, isOK: false, text: &apos;123,456&apos; &#125;, filters: &#123; formatTime: function (value) &#123; //value即为需要过滤的数据 var date = new Date(value) var year = date.getFullYear() var month = padDate(date.getMonth() + 1) var day = padDate(date.getDate()) var hours = padDate(date.getHours()) var minutes = padDate(date.getMinutes()) var seconds = padDate(date.getSeconds()) return year + &apos;-&apos; + month + &apos;-&apos; + day + &apos; &apos; + hours + &apos;:&apos; + minutes + &apos;:&apos; + seconds &#125; &#125;, mounted: function () &#123; // 挂载el后执行 var _this = this this.timer = setInterval(function () &#123; _this.time = new Date() // 修改数据Date &#125;, 1000) &#125;, beforeDestroy () &#123; // 实例销毁之前调用 if (this.timer) &#123; clearInterval(this.timer) &#125; &#125;&#125;)&lt;/script&gt; v-pre:12显示&#123;&#123;&#125;&#125;标签&lt;span v-pre&gt;&#123;&#123;这里的内容不会被编译&#125;&#125;&lt;/span&gt; v-bind:绑定属性，语法糖 :12345678910111213141516171819202122232425262728293031323334&lt;a v-bind:href=&quot;url&quot;&gt;百度&lt;/a&gt;data:&#123; url: &apos;https://www.baidu.com&apos;&#125;绑定class，对象语法和数组语法&lt;div class=&quot;static&quot; v-bind:class=&quot;[&#123; active: isActive, &apos;text-danger&apos;: hasError &#125;, activeClass, errorClass]&quot;&gt;&lt;/div&gt;data: &#123; isActive: true, hasError: false, activeClass: &apos;active&apos;, errorClass: &apos;text-danger&apos;&#125;绑定内联样式&lt;p :style=&quot;[fontStyles, backgroundStyles]&quot;&gt;字体为黄色，大小30px，背景灰色&lt;/p&gt;&lt;script&gt; let fontStyles = &#123; color: &apos;yellow&apos;, fontSize: &apos;30px&apos; &#125; let backgroundStyles = &#123; background: &apos;gray&apos; &#125; data: &#123; fontStyles, backgroundStyles &#125;&lt;/script&gt; v-on:绑定事件，语法糖 @123456&lt;button @click=&quot;add&quot;&gt;加一&lt;/button&gt;methods:&#123; add : function()&#123; this.count++; &#125;&#125; v-model:轻松实现表单输入和应用状态之间的双向绑定12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879808182修饰符v-model.number，仅接受数字输入.trim，自动过滤首尾空白符；.lazy，change时更新内容&lt;div id=&quot;app-6&quot;&gt; &lt;p&gt;&#123;&#123; message &#125;&#125;&lt;/p&gt; &lt;input v-model=&quot;message&quot;&gt;&lt;/div&gt;var app6 = new Vue(&#123; el: &apos;#app-6&apos;, data: &#123; message: &apos;Hello Vue!&apos; &#125;&#125;)多行文本&lt;p style=&quot;white-space: pre-line;&quot;&gt;&#123;&#123; message &#125;&#125;&lt;/p&gt;&lt;br&gt;&lt;textarea v-model=&quot;message&quot; placeholder=&quot;add multiple lines&quot;&gt;&lt;/textarea&gt;复选框&lt;input type=&quot;checkbox&quot; id=&quot;checkbox&quot; v-model=&quot;checked&quot;&gt;&lt;label for=&quot;checkbox&quot;&gt;&#123;&#123; checked &#125;&#125;&lt;/label&gt;多个复选框&lt;div id=&apos;example-3&apos;&gt; &lt;input type=&quot;checkbox&quot; id=&quot;jack&quot; value=&quot;Jack&quot; v-model=&quot;checkedNames&quot;&gt; &lt;label for=&quot;jack&quot;&gt;Jack&lt;/label&gt; &lt;input type=&quot;checkbox&quot; id=&quot;john&quot; value=&quot;John&quot; v-model=&quot;checkedNames&quot;&gt; &lt;label for=&quot;john&quot;&gt;John&lt;/label&gt; &lt;input type=&quot;checkbox&quot; id=&quot;mike&quot; value=&quot;Mike&quot; v-model=&quot;checkedNames&quot;&gt; &lt;label for=&quot;mike&quot;&gt;Mike&lt;/label&gt; &lt;br&gt; &lt;span&gt;Checked names: &#123;&#123; checkedNames &#125;&#125;&lt;/span&gt;&lt;/div&gt;new Vue(&#123; el: &apos;#example-3&apos;, data: &#123; checkedNames: [] &#125;&#125;)单个按钮&lt;div id=&quot;example-4&quot;&gt; &lt;input type=&quot;radio&quot; id=&quot;one&quot; value=&quot;One&quot; v-model=&quot;picked&quot;&gt; &lt;label for=&quot;one&quot;&gt;One&lt;/label&gt; &lt;br&gt; &lt;input type=&quot;radio&quot; id=&quot;two&quot; value=&quot;Two&quot; v-model=&quot;picked&quot;&gt; &lt;label for=&quot;two&quot;&gt;Two&lt;/label&gt; &lt;br&gt; &lt;span&gt;Picked: &#123;&#123; picked &#125;&#125;&lt;/span&gt;&lt;/div&gt;new Vue(&#123; el: &apos;#example-4&apos;, data: &#123; picked: &apos;&apos; &#125;&#125;)选择框&lt;div id=&quot;example-5&quot;&gt; &lt;select v-model=&quot;selected&quot;&gt; &lt;!--multiple属性，多选--&gt; &lt;option v-for=&quot;option in options&quot; v-bind:value=&quot;option.value&quot;&gt; &#123;&#123; option.text &#125;&#125; &lt;/option&gt; &lt;/select&gt; &lt;span&gt;Selected: &#123;&#123; selected &#125;&#125;&lt;/span&gt;&lt;/div&gt;new Vue(&#123; el: &apos;...&apos;, data: &#123; selected: &apos;A&apos;, options: [ &#123; text: &apos;One&apos;, value: &apos;A&apos; &#125;, &#123; text: &apos;Two&apos;, value: &apos;B&apos; &#125;, &#123; text: &apos;Three&apos;, value: &apos;C&apos; &#125; ] &#125;&#125;) 侦听器：watch123456789101112&lt;div&gt;&#123;&#123;msg&#125;&#125;&lt;/div&gt;watch: &#123; msg:function(newVal,oldVal) &#123; console.log(&apos;newVal is: &apos;+newVal); console.log(&apos;oldVal is: &apos;+oldVal); &#125;, another:function(newVal,oldVal) &#123; console.log(&apos;newVal is: &apos;+newVal); console.log(&apos;oldVal is: &apos;+oldVal); &#125; //仅监听一个变量&#125; 计算属性： computed区别watch，computed可以同时监听多个数据，数据联动区别methods，计算属性是基于它们的响应式依赖进行缓存的。只在相关响应式依赖发生改变时它们才会重新求值。methods多次执行，不设置缓存。1234567&lt;div&gt;&#123;&#123;msg1&#125;&#125;&lt;/div&gt;computed: &#123; msg1:function()&#123; return &apos;computed: &apos; + this.msg + &apos;,&apos; + this.another; //监听Vue实例内的两个变量msg和another变量 &#125;&#125; 条件渲染v-if,v-else-if,v-else,v-show123456789101112131415161718192021&lt;div v-if=&quot;count&gt;0&quot;&gt; 判断1：&#123;&#123;count&#125;&#125;&lt;/div&gt;&lt;div v-else-if=&quot;count&lt;=0&amp;&amp;count&gt;-5&quot;&gt; 判断2：&#123;&#123;count&#125;&#125;&lt;/div&gt;&lt;div v-else&gt; 判断3：&#123;&#123;count&#125;&#125;&lt;/div&gt;&lt;div v-show=&quot;bool&quot;&gt; show字段 &lt;/div&gt;&lt;script&gt;var app = new Vue(&#123; el:&apos;#app&apos;, data:&#123; count:0, show:true &#125;&#125;)&lt;/script&gt; 循环列表v-for，:class与样式(:style)绑定123456789101112131415161718&lt;div v-for=&quot;(item, index) in items&quot; :style=&quot;styleMsg&quot; :class=&quot;[&apos;one&apos;,&apos;two&apos;,&#123;&apos;active&apos;:item.age&gt;18&#125;]&quot;&gt; &#123;&#123;item.name&#125;&#125; - &#123;&#123; index &#125;&#125;&lt;/div&gt;styleMsg:&#123; color:&apos;red&apos;, fontSize:&apos;30px&apos;&#125;,items:[ &#123; name:&apos;lili&apos;, age:20 &#125;, &#123; name:&apos;huhu&apos;, age:18 &#125;] HTML 中的特性名是大小写不敏感的，所以浏览器会把所有大写字符解释为小写字符。当在 HTML 中使用大写字母时， DOM 中的模板需转换为小写字母。当 HTML 使用kebab-case (短横线分隔命名) 命名时， DOM 中的模板用 camelCase (驼峰命名法)。 vue-cli 全局安装 npm install -g @vue/cli 通过命令行创建一个项目vue create filePath fileNamecd fileNamenpm run serve 运行项目 或者通过图形界面创建一个项目vue ui 运行服务npm run serve 运行整个vue项目vue serve file.vue 运行单个vue文件 初始化项目依赖vue init template-name || webpack project-namecd project-namenpm install 安装项目所需的依赖 几种常用的调试方法 1.console.log()2.console.error()3.alert()4.debugger5.Vue插件6.Network，查看加载的项，查询http请求；调试页面交互，选择阻塞运行，online选项可选择相应的网速7.window.vue = this 代替debugger，console窗口输入window.vue.元素，window对象绑定8.var app = new vue({})，通过app.元素调试，vm实例]]></content>
      <categories>
        <category>学习</category>
        <category>Vue</category>
      </categories>
      <tags>
        <tag>Vue</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[learnLinux]]></title>
    <url>%2FmarkdownBlog.github.io%2F2019%2F03%2F20%2FlearnLinux%2F</url>
    <content type="text"><![CDATA[ls [-adl]：列出目录 -a ：全部的文件，连同隐藏档( 开头为 . 的文件) 一起列出来-d ：仅列出目录本身，而不是列出目录内的文件数据-l ：长数据串列出，包含文件的属性与权限等等数据 cd: 切换目录 cd filenamecd ~ 切换到/root目录cd.. 切换到上一级目录 pwd [-P]: 显示当前[确实完整的]目录 mkdir [-mp]: 创建一个新的目录 m 配置目录权限p 将目录(包含上一级目录)递归创建 rmdir [-p]: 删除一个空的目录 p连同上级目录一起删除 cp (source) (destination): 复制文件或目录 rm [-fir]: 移除文件或目录 -f ：就是 force 的意思，忽略不存在的文件，不会出现警告信息；-i ：互动模式，在删除前会询问使用者是否动作-r ：递归删除,危险的选项！ mv [-fiu] source destination: 移动文件与目录，或修改文件与目录的名称 -f ：force 强制的意思，如果目标文件已经存在，不会询问而直接覆盖；-i ：若目标文件 (destination) 已经存在时，就会询问是否覆盖！-u ：若目标文件已经存在，且 source 比较新，才会升级 (update) 查看文件内容 cat 由第一行开始显示文件内容tac 从最后一行开始显示，可以看出 tac 是 cat 的倒著写！nl 显示的时候，顺道输出行号！more 一页一页的显示文件内容less 与 more 类似，但是比 more 更好的是，他可以往前翻页！head 只看头几行tail 只看尾巴几行 useradd 选项 用户名选项：-c comment 指定一段注释性描述。-d 目录 指定用户主目录，如果此目录不存在，则同时使用-m选项，可以创建主目录。-g 用户组 指定用户所属的用户组。-G 用户组，用户组 指定用户所属的附加组。-s Shell文件 指定用户的登录Shell。-u 用户号 指定用户的用户号，如果同时有-o选项，则可以重复使用其他用户的标识号。 eg: useradd -d /usr/seasonin -m -g root seasonin创建seasonin用户，用户主目录为/usr/seasonin，属于root组 userdel -r 用户名-r 练用户主目录一起删除 usermod 选项 用户名选项 -c, -d, -m, -g, -G, -s, -u passwd 选项 用户名-l 锁定用户-u 解锁用户-d 使账号无口令（密码）登录-f 强迫用户下次登录修改口令 Linux磁盘管理df 选项 目录或文件名检查文件系统的磁盘空间占用情况。可以利用该命令来获取硬盘被占用了多少空间，目前还剩下多少空间等信息 选项：-a ：列出所有的文件系统，包括系统特有的 /proc 等文件系统；-k ：以 KBytes 的容量显示各文件系统；-m ：以 MBytes 的容量显示各文件系统；-h ：以人们较易阅读的 GBytes, MBytes, KBytes 等格式自行显示；-H ：以 M=1000K 取代 M=1024K 的进位方式；-T ：显示文件系统类型, 连同该 partition 的 filesystem 名称 (例如 ext3) 也列出；-i ：不用硬盘容量，而以 inode 的数量来显示 du 选项 目录或文件名对文件和目录磁盘使用的空间的查看选项：-a ：列出所有的文件与目录容量，因为默认仅统计目录底下的文件量而已。-h ：以人们较易读的容量格式 (G/M) 显示；-s ：列出总量而已，而不列出每个各别的目录占用容量；-S ：不包括子目录下的总计，与 -s 有点差别。-k ：以 KBytes 列出容量显示；-m ：以 MBytes 列出容量显示； fdisk [-l] 装置名称磁盘分区表操作工具-l ：输出后面接的装置所有的分区内容 mkfs [-t 文件系统格式] 装置文件名磁盘格式化-t ：可以接文件系统格式，例如 ext3, ext2, vfat 等 fsck [-t 文件系统] [-ACay] 装置名称磁盘检验选项：-t : 给定档案系统的型式，若在 /etc/fstab 中已有定义或 kernel 本身已支援的则不需加上此参数-s : 依序一个一个地执行 fsck 的指令来检查-A : 对/etc/fstab 中所有列出来的 分区（partition）做检查-C : 显示完整的检查进度-d : 打印出 e2fsck 的 debug 结果-p : 同时有 -A 条件时，同时有多个 fsck 的检查一起执行-R : 同时有 -A 条件时，省略 / 不检查-V : 详细显示模式-a : 如果检查有错则自动修复-r : 如果检查有错则由使用者回答是否修复-y : 选项指定检测每个文件是自动输入yes，在不确定那些是不正常的时候，可以执行 # fsck -y 全部检查修复。 mount [-t 文件系统] [-L Label名] [-o 额外选项] [-n] 装置文件名 挂载点磁盘挂载 umount [-fn] 装置文件名或挂载点磁盘卸载选项：-f ：强制卸除！可用在类似网络文件系统 (NFS) 无法读取到的情况下；-n ：不升级 /etc/mtab 情况下卸除。 Linux yum命令yum [options] [command] [package …]options：可选，选项包括-h（帮助），-y（当安装过程提示选择全部为”yes”），-q（不显示安装的过程）等等。command：要进行的操作。package操作的对象。 yum常用命令1.列出所有可更新的软件清单命令：yum check-update2.更新所有软件命令：yum update3.仅安装指定的软件命令：yum install &lt;package_name&gt;4.仅更新指定的软件命令：yum update &lt;package_name&gt;5.列出所有可安裝的软件清单命令：yum list6.删除软件包命令：yum remove &lt;package_name&gt;7.查找软件包 命令：yum search 8.清除缓存命令:yum clean packages: 清除缓存目录下的软件包yum clean headers: 清除缓存目录下的 headersyum clean oldheaders: 清除缓存目录下旧的 headersyum clean, yum clean all (= yum clean packages; yum clean oldheaders) :清除缓存目录下的软件包及旧的headers]]></content>
      <categories>
        <category>学习</category>
        <category>Linux 文件与目录管理</category>
      </categories>
      <tags>
        <tag>Linux</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[learnNode3]]></title>
    <url>%2FmarkdownBlog.github.io%2F2019%2F03%2F18%2FlearnNode3%2F</url>
    <content type="text"><![CDATA[套接字之间传送的数字称为流，buffer对象在流中传送二进制数据，通过Unicode编码方式传送一个字符串。数据最终包装成数据包传送。套接字通过FIN数据包表明本次传输完成。本次创建一个TCP服务端，监听客户端的数据接收和客户端连接是否关闭。 1234567891011121314var net = require(&apos;net&apos;);var server = net.createServer(function(conn)&#123; console.log(&apos;connected&apos;); conn.on(&apos;data&apos;,function(data)&#123; console.log(data + &apos; from &apos; + conn.remoteAddress + &apos; &apos; + conn.remotePort); conn.write(&apos;Repeating: &apos;+data); &#125;); conn.on(&apos;close&apos;,function()&#123; console.log(&apos;Client closed connection&apos;); &#125;);&#125;).listen(8124);console.log(&apos;listening on port 8124&apos;); 创建TCP客户端，在套接字接口调用setEncoding方法改变接收数据的编码处理方式，转换为UTF8格式，监听数据接收和服务器连接关闭事件。 12345678910111213141516171819202122232425var net = require(&apos;net&apos;);var client = new net.Socket();client.setEncoding(&apos;utf8&apos;);client.connect(&apos;8124&apos;,&apos;localhost&apos;,function()&#123; console.log(&apos;connected to server&apos;); client.write(&apos;Who needs a browser to communicate?&apos;);&#125;);process.stdin.resume();//从终端（命令行）获取数据process.stdin.on(&apos;data&apos;,function(data)&#123; client.write(data);&#125;);client.on(&apos;data&apos;,function(data)&#123; console.log(data);&#125;);client.on(&apos;close&apos;,function()&#123; console.log(&apos;connection is closed&apos;);&#125;); UDP模块的标识符是dgram require(‘dgram’); UDP模块链接 UDP套接字只接受buffer对象，数据包装在buffer对象里面，调用buffer对象的toString方法将缓冲区的数据转换为一个字符串。下面为UDP客户端 12345678910111213var dgram = require(&apos;dgram&apos;);var client = dgram.createSocket(&apos;udp4&apos;);//创建UDP套接字参数udp4或udp6process.stdin.on(&apos;data&apos;,function(data)&#123; console.log(data.toString(&apos;utf8&apos;)); client.send(data,0,data.length,8124,&quot;localhost&quot;,function(err,bytes)&#123; if(err) console.log(&apos;error&apos;+err); else console.log(&apos;successful&apos;); &#125;);&#125;); UDP服务器端 12345678var dgram = require(&apos;dgram&apos;);var server = dgram.createSocket(&quot;udp4&quot;);server.on(&quot;message&quot;,function(msg,rinfo)&#123; console.log(&quot;message: &quot;+msg+&quot; from &quot; + rinfo.address+&quot;:&quot;+rinfo.port);&#125;);server.bind(8124); 无论UDP客户端还是服务端，不用使用close方法关闭套接字，因为没有维护一个持续连接 pine可将一个可读流和一个可写流连接起来12process.stdin.resume();process.stdin.pipe(process.stdout); readline1234567891011121314151617181920212223242526272829303132var readline = require(&apos;readline&apos;);var interface = readline.createInterface(process.stdin,process.stdout,null);interface.question(&quot;&gt;&gt;What is the meaning of meaning of life?&quot;,function(answer)&#123; console.log(&quot;About the meaning of life, you said &quot;+answer); interface.setPrompt(&quot;&gt;&gt;&quot;); interface.prompt();&#125;);function closeInterface()&#123; console.log(&apos;Leaving interface...&apos;); process.exit();&#125;interface.on(&apos;line&apos;,function(cmd)&#123; //input流接收到行尾输入（，或）\n，就会发出该事件 if(cmd.trim()==&apos;.leave&apos;) &#123; closeInterface(); return; &#125; else &#123; console.log(&quot;repeating command: &quot;+cmd); &#125; interface.setPrompt(&quot;&gt;&gt;&quot;); //rl.setPrompt()方法设置将在output每次rl.prompt()调用时写入的提示 interface.prompt(); //rl.prompt()方法将readline.Interface配置的实例 写入prompt新行，output以便为用户提供提供输入的新位置&#125;);interface.on(&apos;close&apos;,function()&#123; closeInterface();&#125;);]]></content>
      <categories>
        <category>学习</category>
        <category>node.js TCP服务器</category>
      </categories>
      <tags>
        <tag>node.js</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[useGit]]></title>
    <url>%2FmarkdownBlog.github.io%2F2019%2F03%2F10%2FuseGit%2F</url>
    <content type="text"><![CDATA[git常用命令 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879mkdir &lt;file&gt; 创建文件夹cd &lt;file&gt; 跳到具体文件夹pwd 显示当前路径git init 初始化git仓库git add &lt;filename&gt; 提交文件到仓库git add . 提交本地所有文件到仓库git commit -m&quot;describe&quot; 添加说明git status 仓库当前的状态git diff 查看修改的内容git log 查看历史记录，可查看版本号git log --pretty=oneline 查看一行记录git reflog 查看历史命令git reset --hard HEAD^ 返回到上一版本HEAD为当前版本，HEAD^为上一版本，同样HEAD^^为上上版本git reset --hard 版本号 返回到某一具体版本git checkout --&lt;filename&gt; 丢弃工作区的内容，即add提交的内容git reset HEAD &lt;filename&gt; 丢弃暂存区，回到工作区，即丢弃commit的内容git rm file 从版本库中删除文件rm file 删除文件git checkout --file 从版本库的文件替换工作区的文件ssh-keygen -t rsa -C &quot;email&quot; 创建SSH KEYgit remote add origin 仓库地址 关联远程库，库名origin可设其它git push -u origin master 第一次向远程库origin推送master分支的所有内容 git push origin master 向远程库origin推送master分支的最新内容git clone 仓库地址 克隆远程仓库，库名默认origingit checkout -b dev 创建并切换到dev分支git branch dev 创建dev分支git checkout dev 切换到dev分支git branch 查看当前分支git merge dev 把dev分支合并到当前分支下git branch -d dev 删除dev分支git log --graph 查看分支合并图git log --graph --pretty=oneline --abbrev-commit 查看简洁（一行）的分支合并图git merge --no-ff -m&quot;描述&quot; dev 采用no-ff普通模式的方式合并dev分支，会创建一个新的commit，加上-m描述git merge dev 默认采用fast -forward模式合并，会丢失分支信息合并分支步骤：1.合并无冲突，删除分支2.合并有冲突，手动修改冲突内容，提交内容，删除分支git stash 储藏未完成的工作，即储存工作区的内容，可恢复后台继续工作git stash list 查看工作现场git stash pop 恢复工作现场并删除stash内容git remote 查看远程库信息git remote -v 查看远程库详细信息git push origin dev 推送dev分支的内容到远程库推送失败处理步骤：git pull 抓取远程库的最新提交的内容，并手动解决冲突git checkout -b branch-name origin/branch-name 在本地创建和远程分支的关联git rebase 将提交到某一分支的所有内容修改并移到另一条分支上git tag &lt;tagname&gt; commiID 在最新提交的commit上打上标签，即默认commitID为HEAD，否则对应id打标签git tag -a &lt;tagname&gt; -m&quot;描述&quot; commitID 指定标签来添加描述git tag 查看所有标签git show &lt;tagname&gt; 查看标签信息git tag -d tagname 删除标签git push origin tagname 把本地标签推送到远程库git push origin --tags 一次推送全部本地标签到远程库git push origin irefs/tags/&lt;tagname&gt; 删除远程标签git remote rm origin 删除与远程库origin的联系根目录下创建.gitignore文件，填写文件名，该文件会被忽略]]></content>
      <categories>
        <category>学习</category>
        <category>命令</category>
      </categories>
      <tags>
        <tag>git</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[第一次]]></title>
    <url>%2FmarkdownBlog.github.io%2F2019%2F03%2F10%2FfirstTime%2F</url>
    <content type="text"><![CDATA[本人的第一个博客开通啦！我是谁？我从哪里来？又到那里去？这是一个有深意的问题。本人热爱学习，正在前端与后台领域奋斗 以下为初次练习Markdown 六级标题段落末尾两个以上空格加上回车 列表1 列表2 列表项 列表项 vue导航 斜体字加粗字删除线下划线 &lt;html&gt;一行代码嵌入区&lt;/html&gt; 123456&lt;html&gt;&lt;head&gt;标题&lt;/head&gt;&lt;body&gt; &lt;div&gt;&lt;p&gt;body主体&lt;/p&gt;&lt;/div&gt;&lt;/body&gt;&lt;/html&gt; 引用内容 分行]]></content>
      <categories>
        <category>我们聊聊</category>
      </categories>
      <tags>
        <tag>介绍</tag>
      </tags>
  </entry>
</search>
